<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - /opt/ros/kinetic/include/opencv-3.3.1-dev/opencv2/core/mat.hpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../index.html">top level</a> - <a href="index.html">opt/ros/kinetic/include/opencv-3.3.1-dev/opencv2/core</a> - mat.hpp<span style="font-size: 80%;"> (source / <a href="mat.hpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-12-14 05:28:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr><td><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*M///////////////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">       2 </span>            : //
<span class="lineNum">       3 </span>            : //  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
<span class="lineNum">       4 </span>            : //
<span class="lineNum">       5 </span>            : //  By downloading, copying, installing or using the software you agree to this license.
<span class="lineNum">       6 </span>            : //  If you do not agree to this license, do not download, install,
<span class="lineNum">       7 </span>            : //  copy or use the software.
<span class="lineNum">       8 </span>            : //
<span class="lineNum">       9 </span>            : //
<span class="lineNum">      10 </span>            : //                          License Agreement
<span class="lineNum">      11 </span>            : //                For Open Source Computer Vision Library
<span class="lineNum">      12 </span>            : //
<span class="lineNum">      13 </span>            : // Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
<span class="lineNum">      14 </span>            : // Copyright (C) 2009, Willow Garage Inc., all rights reserved.
<span class="lineNum">      15 </span>            : // Copyright (C) 2013, OpenCV Foundation, all rights reserved.
<span class="lineNum">      16 </span>            : // Third party copyrights are property of their respective owners.
<span class="lineNum">      17 </span>            : //
<span class="lineNum">      18 </span>            : // Redistribution and use in source and binary forms, with or without modification,
<span class="lineNum">      19 </span>            : // are permitted provided that the following conditions are met:
<span class="lineNum">      20 </span>            : //
<span class="lineNum">      21 </span>            : //   * Redistribution's of source code must retain the above copyright notice,
<span class="lineNum">      22 </span>            : //     this list of conditions and the following disclaimer.
<span class="lineNum">      23 </span>            : //
<span class="lineNum">      24 </span>            : //   * Redistribution's in binary form must reproduce the above copyright notice,
<span class="lineNum">      25 </span>            : //     this list of conditions and the following disclaimer in the documentation
<span class="lineNum">      26 </span>            : //     and/or other materials provided with the distribution.
<span class="lineNum">      27 </span>            : //
<span class="lineNum">      28 </span>            : //   * The name of the copyright holders may not be used to endorse or promote products
<span class="lineNum">      29 </span>            : //     derived from this software without specific prior written permission.
<span class="lineNum">      30 </span>            : //
<span class="lineNum">      31 </span>            : // This software is provided by the copyright holders and contributors &quot;as is&quot; and
<span class="lineNum">      32 </span>            : // any express or implied warranties, including, but not limited to, the implied
<span class="lineNum">      33 </span>            : // warranties of merchantability and fitness for a particular purpose are disclaimed.
<span class="lineNum">      34 </span>            : // In no event shall the Intel Corporation or contributors be liable for any direct,
<span class="lineNum">      35 </span>            : // indirect, incidental, special, exemplary, or consequential damages
<span class="lineNum">      36 </span>            : // (including, but not limited to, procurement of substitute goods or services;
<span class="lineNum">      37 </span>            : // loss of use, data, or profits; or business interruption) however caused
<span class="lineNum">      38 </span>            : // and on any theory of liability, whether in contract, strict liability,
<span class="lineNum">      39 </span>            : // or tort (including negligence or otherwise) arising in any way out of
<span class="lineNum">      40 </span>            : // the use of this software, even if advised of the possibility of such damage.
<span class="lineNum">      41 </span>            : //
<span class="lineNum">      42 </span>            : //M*/
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : #ifndef OPENCV_CORE_MAT_HPP
<span class="lineNum">      45 </span>            : #define OPENCV_CORE_MAT_HPP
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : #ifndef __cplusplus
<span class="lineNum">      48 </span>            : #  error mat.hpp header must be compiled as C++
<span class="lineNum">      49 </span>            : #endif
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : #include &quot;opencv2/core/matx.hpp&quot;
<span class="lineNum">      52 </span>            : #include &quot;opencv2/core/types.hpp&quot;
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : #include &quot;opencv2/core/bufferpool.hpp&quot;
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : #ifdef CV_CXX11
<span class="lineNum">      57 </span>            : #include &lt;type_traits&gt;
<span class="lineNum">      58 </span>            : #endif
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : namespace cv
<span class="lineNum">      61 </span>            : {
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : //! @addtogroup core_basic
<span class="lineNum">      64 </span>            : //! @{
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : enum { ACCESS_READ=1&lt;&lt;24, ACCESS_WRITE=1&lt;&lt;25,
<span class="lineNum">      67 </span>            :     ACCESS_RW=3&lt;&lt;24, ACCESS_MASK=ACCESS_RW, ACCESS_FAST=1&lt;&lt;26 };
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : CV__DEBUG_NS_BEGIN
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : class CV_EXPORTS _OutputArray;
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : //////////////////////// Input/Output Array Arguments /////////////////////////////////
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : /** @brief This is the proxy class for passing read-only input arrays into OpenCV functions.
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : It is defined as:
<span class="lineNum">      78 </span>            : @code
<span class="lineNum">      79 </span>            :     typedef const _InputArray&amp; InputArray;
<span class="lineNum">      80 </span>            : @endcode
<span class="lineNum">      81 </span>            : where _InputArray is a class that can be constructed from `Mat`, `Mat_&lt;T&gt;`, `Matx&lt;T, m, n&gt;`,
<span class="lineNum">      82 </span>            : `std::vector&lt;T&gt;`, `std::vector&lt;std::vector&lt;T&gt; &gt;`, `std::vector&lt;Mat&gt;`, `std::vector&lt;Mat_&lt;T&gt; &gt;`,
<span class="lineNum">      83 </span>            : `UMat`, `std::vector&lt;UMat&gt;` or `double`. It can also be constructed from a matrix expression.
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : Since this is mostly implementation-level class, and its interface may change in future versions, we
<span class="lineNum">      86 </span>            : do not describe it in details. There are a few key things, though, that should be kept in mind:
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : -   When you see in the reference manual or in OpenCV source code a function that takes
<span class="lineNum">      89 </span>            :     InputArray, it means that you can actually pass `Mat`, `Matx`, `vector&lt;T&gt;` etc. (see above the
<span class="lineNum">      90 </span>            :     complete list).
<span class="lineNum">      91 </span>            : -   Optional input arguments: If some of the input arrays may be empty, pass cv::noArray() (or
<span class="lineNum">      92 </span>            :     simply cv::Mat() as you probably did before).
<span class="lineNum">      93 </span>            : -   The class is designed solely for passing parameters. That is, normally you *should not*
<span class="lineNum">      94 </span>            :     declare class members, local and global variables of this type.
<span class="lineNum">      95 </span>            : -   If you want to design your own function or a class method that can operate of arrays of
<span class="lineNum">      96 </span>            :     multiple types, you can use InputArray (or OutputArray) for the respective parameters. Inside
<span class="lineNum">      97 </span>            :     a function you should use _InputArray::getMat() method to construct a matrix header for the
<span class="lineNum">      98 </span>            :     array (without copying data). _InputArray::kind() can be used to distinguish Mat from
<span class="lineNum">      99 </span>            :     `vector&lt;&gt;` etc., but normally it is not needed.
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : Here is how you can use a function that takes InputArray :
<span class="lineNum">     102 </span>            : @code
<span class="lineNum">     103 </span>            :     std::vector&lt;Point2f&gt; vec;
<span class="lineNum">     104 </span>            :     // points or a circle
<span class="lineNum">     105 </span>            :     for( int i = 0; i &lt; 30; i++ )
<span class="lineNum">     106 </span>            :         vec.push_back(Point2f((float)(100 + 30*cos(i*CV_PI*2/5)),
<span class="lineNum">     107 </span>            :                               (float)(100 - 30*sin(i*CV_PI*2/5))));
<span class="lineNum">     108 </span>            :     cv::transform(vec, vec, cv::Matx23f(0.707, -0.707, 10, 0.707, 0.707, 20));
<span class="lineNum">     109 </span>            : @endcode
<span class="lineNum">     110 </span>            : That is, we form an STL vector containing points, and apply in-place affine transformation to the
<span class="lineNum">     111 </span>            : vector using the 2x3 matrix created inline as `Matx&lt;float, 2, 3&gt;` instance.
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : Here is how such a function can be implemented (for simplicity, we implement a very specific case of
<span class="lineNum">     114 </span>            : it, according to the assertion statement inside) :
<span class="lineNum">     115 </span>            : @code
<span class="lineNum">     116 </span>            :     void myAffineTransform(InputArray _src, OutputArray _dst, InputArray _m)
<span class="lineNum">     117 </span>            :     {
<span class="lineNum">     118 </span>            :         // get Mat headers for input arrays. This is O(1) operation,
<span class="lineNum">     119 </span>            :         // unless _src and/or _m are matrix expressions.
<span class="lineNum">     120 </span>            :         Mat src = _src.getMat(), m = _m.getMat();
<span class="lineNum">     121 </span>            :         CV_Assert( src.type() == CV_32FC2 &amp;&amp; m.type() == CV_32F &amp;&amp; m.size() == Size(3, 2) );
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            :         // [re]create the output array so that it has the proper size and type.
<span class="lineNum">     124 </span>            :         // In case of Mat it calls Mat::create, in case of STL vector it calls vector::resize.
<span class="lineNum">     125 </span>            :         _dst.create(src.size(), src.type());
<span class="lineNum">     126 </span>            :         Mat dst = _dst.getMat();
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :         for( int i = 0; i &lt; src.rows; i++ )
<span class="lineNum">     129 </span>            :             for( int j = 0; j &lt; src.cols; j++ )
<span class="lineNum">     130 </span>            :             {
<span class="lineNum">     131 </span>            :                 Point2f pt = src.at&lt;Point2f&gt;(i, j);
<span class="lineNum">     132 </span>            :                 dst.at&lt;Point2f&gt;(i, j) = Point2f(m.at&lt;float&gt;(0, 0)*pt.x +
<span class="lineNum">     133 </span>            :                                                 m.at&lt;float&gt;(0, 1)*pt.y +
<span class="lineNum">     134 </span>            :                                                 m.at&lt;float&gt;(0, 2),
<span class="lineNum">     135 </span>            :                                                 m.at&lt;float&gt;(1, 0)*pt.x +
<span class="lineNum">     136 </span>            :                                                 m.at&lt;float&gt;(1, 1)*pt.y +
<span class="lineNum">     137 </span>            :                                                 m.at&lt;float&gt;(1, 2));
<span class="lineNum">     138 </span>            :             }
<span class="lineNum">     139 </span>            :     }
<span class="lineNum">     140 </span>            : @endcode
<span class="lineNum">     141 </span>            : There is another related type, InputArrayOfArrays, which is currently defined as a synonym for
<span class="lineNum">     142 </span>            : InputArray:
<span class="lineNum">     143 </span>            : @code
<span class="lineNum">     144 </span>            :     typedef InputArray InputArrayOfArrays;
<span class="lineNum">     145 </span>            : @endcode
<span class="lineNum">     146 </span>            : It denotes function arguments that are either vectors of vectors or vectors of matrices. A separate
<span class="lineNum">     147 </span>            : synonym is needed to generate Python/Java etc. wrappers properly. At the function implementation
<span class="lineNum">     148 </span>            : level their use is similar, but _InputArray::getMat(idx) should be used to get header for the
<span class="lineNum">     149 </span>            : idx-th component of the outer vector and _InputArray::size().area() should be used to find the
<span class="lineNum">     150 </span>            : number of components (vectors/matrices) of the outer vector.
<span class="lineNum">     151 </span>            :  */
<span class="lineNum">     152 </span>            : class CV_EXPORTS _InputArray
<span class="lineNum">     153 </span>            : {
<span class="lineNum">     154 </span>            : public:
<span class="lineNum">     155 </span>            :     enum {
<span class="lineNum">     156 </span>            :         KIND_SHIFT = 16,
<span class="lineNum">     157 </span>            :         FIXED_TYPE = 0x8000 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     158 </span>            :         FIXED_SIZE = 0x4000 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     159 </span>            :         KIND_MASK = 31 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :         NONE              = 0 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     162 </span>            :         MAT               = 1 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     163 </span>            :         MATX              = 2 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     164 </span>            :         STD_VECTOR        = 3 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     165 </span>            :         STD_VECTOR_VECTOR = 4 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     166 </span>            :         STD_VECTOR_MAT    = 5 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     167 </span>            :         EXPR              = 6 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     168 </span>            :         OPENGL_BUFFER     = 7 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     169 </span>            :         CUDA_HOST_MEM     = 8 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     170 </span>            :         CUDA_GPU_MAT      = 9 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     171 </span>            :         UMAT              =10 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     172 </span>            :         STD_VECTOR_UMAT   =11 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     173 </span>            :         STD_BOOL_VECTOR   =12 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     174 </span>            :         STD_VECTOR_CUDA_GPU_MAT = 13 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     175 </span>            :         STD_ARRAY         =14 &lt;&lt; KIND_SHIFT,
<span class="lineNum">     176 </span>            :         STD_ARRAY_MAT     =15 &lt;&lt; KIND_SHIFT
<span class="lineNum">     177 </span>            :     };
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            :     _InputArray();
<span class="lineNum">     180 </span>            :     _InputArray(int _flags, void* _obj);
<span class="lineNum">     181 </span>            :     _InputArray(const Mat&amp; m);
<span class="lineNum">     182 </span>            :     _InputArray(const MatExpr&amp; expr);
<span class="lineNum">     183 </span>            :     _InputArray(const std::vector&lt;Mat&gt;&amp; vec);
<span class="lineNum">     184 </span>            :     template&lt;typename _Tp&gt; _InputArray(const Mat_&lt;_Tp&gt;&amp; m);
<span class="lineNum">     185 </span>            :     template&lt;typename _Tp&gt; _InputArray(const std::vector&lt;_Tp&gt;&amp; vec);
<span class="lineNum">     186 </span>            :     _InputArray(const std::vector&lt;bool&gt;&amp; vec);
<span class="lineNum">     187 </span>            :     template&lt;typename _Tp&gt; _InputArray(const std::vector&lt;std::vector&lt;_Tp&gt; &gt;&amp; vec);
<span class="lineNum">     188 </span>            :     _InputArray(const std::vector&lt;std::vector&lt;bool&gt; &gt;&amp;);
<span class="lineNum">     189 </span>            :     template&lt;typename _Tp&gt; _InputArray(const std::vector&lt;Mat_&lt;_Tp&gt; &gt;&amp; vec);
<span class="lineNum">     190 </span>            :     template&lt;typename _Tp&gt; _InputArray(const _Tp* vec, int n);
<span class="lineNum">     191 </span>            :     template&lt;typename _Tp, int m, int n&gt; _InputArray(const Matx&lt;_Tp, m, n&gt;&amp; matx);
<span class="lineNum">     192 </span>            :     _InputArray(const double&amp; val);
<span class="lineNum">     193 </span>            :     _InputArray(const cuda::GpuMat&amp; d_mat);
<span class="lineNum">     194 </span>            :     _InputArray(const std::vector&lt;cuda::GpuMat&gt;&amp; d_mat_array);
<span class="lineNum">     195 </span>            :     _InputArray(const ogl::Buffer&amp; buf);
<span class="lineNum">     196 </span>            :     _InputArray(const cuda::HostMem&amp; cuda_mem);
<span class="lineNum">     197 </span>            :     template&lt;typename _Tp&gt; _InputArray(const cudev::GpuMat_&lt;_Tp&gt;&amp; m);
<span class="lineNum">     198 </span>            :     _InputArray(const UMat&amp; um);
<span class="lineNum">     199 </span>            :     _InputArray(const std::vector&lt;UMat&gt;&amp; umv);
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : #ifdef CV_CXX_STD_ARRAY
<span class="lineNum">     202 </span>            :     template&lt;typename _Tp, std::size_t _Nm&gt; _InputArray(const std::array&lt;_Tp, _Nm&gt;&amp; arr);
<span class="lineNum">     203 </span>            :     template&lt;std::size_t _Nm&gt; _InputArray(const std::array&lt;Mat, _Nm&gt;&amp; arr);
<span class="lineNum">     204 </span>            : #endif
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :     Mat getMat(int idx=-1) const;
<span class="lineNum">     207 </span>            :     Mat getMat_(int idx=-1) const;
<span class="lineNum">     208 </span>            :     UMat getUMat(int idx=-1) const;
<span class="lineNum">     209 </span>            :     void getMatVector(std::vector&lt;Mat&gt;&amp; mv) const;
<span class="lineNum">     210 </span>            :     void getUMatVector(std::vector&lt;UMat&gt;&amp; umv) const;
<span class="lineNum">     211 </span>            :     void getGpuMatVector(std::vector&lt;cuda::GpuMat&gt;&amp; gpumv) const;
<span class="lineNum">     212 </span>            :     cuda::GpuMat getGpuMat() const;
<span class="lineNum">     213 </span>            :     ogl::Buffer getOGlBuffer() const;
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :     int getFlags() const;
<span class="lineNum">     216 </span>            :     void* getObj() const;
<span class="lineNum">     217 </span>            :     Size getSz() const;
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            :     int kind() const;
<span class="lineNum">     220 </span>            :     int dims(int i=-1) const;
<span class="lineNum">     221 </span>            :     int cols(int i=-1) const;
<span class="lineNum">     222 </span>            :     int rows(int i=-1) const;
<span class="lineNum">     223 </span>            :     Size size(int i=-1) const;
<span class="lineNum">     224 </span>            :     int sizend(int* sz, int i=-1) const;
<span class="lineNum">     225 </span>            :     bool sameSize(const _InputArray&amp; arr) const;
<span class="lineNum">     226 </span>            :     size_t total(int i=-1) const;
<span class="lineNum">     227 </span>            :     int type(int i=-1) const;
<span class="lineNum">     228 </span>            :     int depth(int i=-1) const;
<span class="lineNum">     229 </span>            :     int channels(int i=-1) const;
<span class="lineNum">     230 </span>            :     bool isContinuous(int i=-1) const;
<span class="lineNum">     231 </span>            :     bool isSubmatrix(int i=-1) const;
<span class="lineNum">     232 </span>            :     bool empty() const;
<span class="lineNum">     233 </span>            :     void copyTo(const _OutputArray&amp; arr) const;
<span class="lineNum">     234 </span>            :     void copyTo(const _OutputArray&amp; arr, const _InputArray &amp; mask) const;
<span class="lineNum">     235 </span>            :     size_t offset(int i=-1) const;
<span class="lineNum">     236 </span>            :     size_t step(int i=-1) const;
<span class="lineNum">     237 </span>            :     bool isMat() const;
<span class="lineNum">     238 </span>            :     bool isUMat() const;
<span class="lineNum">     239 </span>            :     bool isMatVector() const;
<span class="lineNum">     240 </span>            :     bool isUMatVector() const;
<span class="lineNum">     241 </span>            :     bool isMatx() const;
<span class="lineNum">     242 </span>            :     bool isVector() const;
<span class="lineNum">     243 </span>            :     bool isGpuMatVector() const;
<span class="lineNum">     244 </span>            :     ~_InputArray();
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            : protected:
<span class="lineNum">     247 </span>            :     int flags;
<span class="lineNum">     248 </span>            :     void* obj;
<span class="lineNum">     249 </span>            :     Size sz;
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            :     void init(int _flags, const void* _obj);
<span class="lineNum">     252 </span>            :     void init(int _flags, const void* _obj, Size _sz);
<span class="lineNum">     253 </span>            : };
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            : /** @brief This type is very similar to InputArray except that it is used for input/output and output function
<span class="lineNum">     257 </span>            : parameters.
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : Just like with InputArray, OpenCV users should not care about OutputArray, they just pass `Mat`,
<span class="lineNum">     260 </span>            : `vector&lt;T&gt;` etc. to the functions. The same limitation as for `InputArray`: *Do not explicitly
<span class="lineNum">     261 </span>            : create OutputArray instances* applies here too.
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : If you want to make your function polymorphic (i.e. accept different arrays as output parameters),
<span class="lineNum">     264 </span>            : it is also not very difficult. Take the sample above as the reference. Note that
<span class="lineNum">     265 </span>            : _OutputArray::create() needs to be called before _OutputArray::getMat(). This way you guarantee
<span class="lineNum">     266 </span>            : that the output array is properly allocated.
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            : Optional output parameters. If you do not need certain output array to be computed and returned to
<span class="lineNum">     269 </span>            : you, pass cv::noArray(), just like you would in the case of optional input array. At the
<span class="lineNum">     270 </span>            : implementation level, use _OutputArray::needed() to check if certain output array needs to be
<span class="lineNum">     271 </span>            : computed or not.
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            : There are several synonyms for OutputArray that are used to assist automatic Python/Java/... wrapper
<span class="lineNum">     274 </span>            : generators:
<span class="lineNum">     275 </span>            : @code
<span class="lineNum">     276 </span>            :     typedef OutputArray OutputArrayOfArrays;
<span class="lineNum">     277 </span>            :     typedef OutputArray InputOutputArray;
<span class="lineNum">     278 </span>            :     typedef OutputArray InputOutputArrayOfArrays;
<a name="279"><span class="lineNum">     279 </span>            : @endcode</a>
<span class="lineNum">     280 </span>            :  */
<span class="lineNum">     281 </span><span class="lineCov">         32 : class CV_EXPORTS _OutputArray : public _InputArray</span>
<span class="lineNum">     282 </span>            : {
<span class="lineNum">     283 </span>            : public:
<span class="lineNum">     284 </span>            :     enum
<span class="lineNum">     285 </span>            :     {
<span class="lineNum">     286 </span>            :         DEPTH_MASK_8U = 1 &lt;&lt; CV_8U,
<span class="lineNum">     287 </span>            :         DEPTH_MASK_8S = 1 &lt;&lt; CV_8S,
<span class="lineNum">     288 </span>            :         DEPTH_MASK_16U = 1 &lt;&lt; CV_16U,
<span class="lineNum">     289 </span>            :         DEPTH_MASK_16S = 1 &lt;&lt; CV_16S,
<span class="lineNum">     290 </span>            :         DEPTH_MASK_32S = 1 &lt;&lt; CV_32S,
<span class="lineNum">     291 </span>            :         DEPTH_MASK_32F = 1 &lt;&lt; CV_32F,
<span class="lineNum">     292 </span>            :         DEPTH_MASK_64F = 1 &lt;&lt; CV_64F,
<span class="lineNum">     293 </span>            :         DEPTH_MASK_ALL = (DEPTH_MASK_64F&lt;&lt;1)-1,
<span class="lineNum">     294 </span>            :         DEPTH_MASK_ALL_BUT_8S = DEPTH_MASK_ALL &amp; ~DEPTH_MASK_8S,
<span class="lineNum">     295 </span>            :         DEPTH_MASK_FLT = DEPTH_MASK_32F + DEPTH_MASK_64F
<span class="lineNum">     296 </span>            :     };
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :     _OutputArray();
<span class="lineNum">     299 </span>            :     _OutputArray(int _flags, void* _obj);
<span class="lineNum">     300 </span>            :     _OutputArray(Mat&amp; m);
<span class="lineNum">     301 </span>            :     _OutputArray(std::vector&lt;Mat&gt;&amp; vec);
<span class="lineNum">     302 </span>            :     _OutputArray(cuda::GpuMat&amp; d_mat);
<span class="lineNum">     303 </span>            :     _OutputArray(std::vector&lt;cuda::GpuMat&gt;&amp; d_mat);
<span class="lineNum">     304 </span>            :     _OutputArray(ogl::Buffer&amp; buf);
<span class="lineNum">     305 </span>            :     _OutputArray(cuda::HostMem&amp; cuda_mem);
<span class="lineNum">     306 </span>            :     template&lt;typename _Tp&gt; _OutputArray(cudev::GpuMat_&lt;_Tp&gt;&amp; m);
<span class="lineNum">     307 </span>            :     template&lt;typename _Tp&gt; _OutputArray(std::vector&lt;_Tp&gt;&amp; vec);
<span class="lineNum">     308 </span>            :     _OutputArray(std::vector&lt;bool&gt;&amp; vec);
<span class="lineNum">     309 </span>            :     template&lt;typename _Tp&gt; _OutputArray(std::vector&lt;std::vector&lt;_Tp&gt; &gt;&amp; vec);
<span class="lineNum">     310 </span>            :     _OutputArray(std::vector&lt;std::vector&lt;bool&gt; &gt;&amp;);
<span class="lineNum">     311 </span>            :     template&lt;typename _Tp&gt; _OutputArray(std::vector&lt;Mat_&lt;_Tp&gt; &gt;&amp; vec);
<span class="lineNum">     312 </span>            :     template&lt;typename _Tp&gt; _OutputArray(Mat_&lt;_Tp&gt;&amp; m);
<span class="lineNum">     313 </span>            :     template&lt;typename _Tp&gt; _OutputArray(_Tp* vec, int n);
<span class="lineNum">     314 </span>            :     template&lt;typename _Tp, int m, int n&gt; _OutputArray(Matx&lt;_Tp, m, n&gt;&amp; matx);
<span class="lineNum">     315 </span>            :     _OutputArray(UMat&amp; m);
<span class="lineNum">     316 </span>            :     _OutputArray(std::vector&lt;UMat&gt;&amp; vec);
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            :     _OutputArray(const Mat&amp; m);
<span class="lineNum">     319 </span>            :     _OutputArray(const std::vector&lt;Mat&gt;&amp; vec);
<span class="lineNum">     320 </span>            :     _OutputArray(const cuda::GpuMat&amp; d_mat);
<span class="lineNum">     321 </span>            :     _OutputArray(const std::vector&lt;cuda::GpuMat&gt;&amp; d_mat);
<span class="lineNum">     322 </span>            :     _OutputArray(const ogl::Buffer&amp; buf);
<span class="lineNum">     323 </span>            :     _OutputArray(const cuda::HostMem&amp; cuda_mem);
<span class="lineNum">     324 </span>            :     template&lt;typename _Tp&gt; _OutputArray(const cudev::GpuMat_&lt;_Tp&gt;&amp; m);
<span class="lineNum">     325 </span>            :     template&lt;typename _Tp&gt; _OutputArray(const std::vector&lt;_Tp&gt;&amp; vec);
<span class="lineNum">     326 </span>            :     template&lt;typename _Tp&gt; _OutputArray(const std::vector&lt;std::vector&lt;_Tp&gt; &gt;&amp; vec);
<span class="lineNum">     327 </span>            :     template&lt;typename _Tp&gt; _OutputArray(const std::vector&lt;Mat_&lt;_Tp&gt; &gt;&amp; vec);
<span class="lineNum">     328 </span>            :     template&lt;typename _Tp&gt; _OutputArray(const Mat_&lt;_Tp&gt;&amp; m);
<span class="lineNum">     329 </span>            :     template&lt;typename _Tp&gt; _OutputArray(const _Tp* vec, int n);
<span class="lineNum">     330 </span>            :     template&lt;typename _Tp, int m, int n&gt; _OutputArray(const Matx&lt;_Tp, m, n&gt;&amp; matx);
<span class="lineNum">     331 </span>            :     _OutputArray(const UMat&amp; m);
<span class="lineNum">     332 </span>            :     _OutputArray(const std::vector&lt;UMat&gt;&amp; vec);
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            : #ifdef CV_CXX_STD_ARRAY
<span class="lineNum">     335 </span>            :     template&lt;typename _Tp, std::size_t _Nm&gt; _OutputArray(std::array&lt;_Tp, _Nm&gt;&amp; arr);
<span class="lineNum">     336 </span>            :     template&lt;typename _Tp, std::size_t _Nm&gt; _OutputArray(const std::array&lt;_Tp, _Nm&gt;&amp; arr);
<span class="lineNum">     337 </span>            :     template&lt;std::size_t _Nm&gt; _OutputArray(std::array&lt;Mat, _Nm&gt;&amp; arr);
<span class="lineNum">     338 </span>            :     template&lt;std::size_t _Nm&gt; _OutputArray(const std::array&lt;Mat, _Nm&gt;&amp; arr);
<span class="lineNum">     339 </span>            : #endif
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            :     bool fixedSize() const;
<span class="lineNum">     342 </span>            :     bool fixedType() const;
<span class="lineNum">     343 </span>            :     bool needed() const;
<span class="lineNum">     344 </span>            :     Mat&amp; getMatRef(int i=-1) const;
<span class="lineNum">     345 </span>            :     UMat&amp; getUMatRef(int i=-1) const;
<span class="lineNum">     346 </span>            :     cuda::GpuMat&amp; getGpuMatRef() const;
<span class="lineNum">     347 </span>            :     std::vector&lt;cuda::GpuMat&gt;&amp; getGpuMatVecRef() const;
<span class="lineNum">     348 </span>            :     ogl::Buffer&amp; getOGlBufferRef() const;
<span class="lineNum">     349 </span>            :     cuda::HostMem&amp; getHostMemRef() const;
<span class="lineNum">     350 </span>            :     void create(Size sz, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const;
<span class="lineNum">     351 </span>            :     void create(int rows, int cols, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const;
<span class="lineNum">     352 </span>            :     void create(int dims, const int* size, int type, int i=-1, bool allowTransposed=false, int fixedDepthMask=0) const;
<span class="lineNum">     353 </span>            :     void createSameSize(const _InputArray&amp; arr, int mtype) const;
<span class="lineNum">     354 </span>            :     void release() const;
<span class="lineNum">     355 </span>            :     void clear() const;
<span class="lineNum">     356 </span>            :     void setTo(const _InputArray&amp; value, const _InputArray &amp; mask = _InputArray()) const;
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            :     void assign(const UMat&amp; u) const;
<span class="lineNum">     359 </span>            :     void assign(const Mat&amp; m) const;
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :     void assign(const std::vector&lt;UMat&gt;&amp; v) const;
<span class="lineNum">     362 </span>            :     void assign(const std::vector&lt;Mat&gt;&amp; v) const;
<span class="lineNum">     363 </span>            : };
<a name="364"><span class="lineNum">     364 </span>            : </a>
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span><span class="lineCov">         10 : class CV_EXPORTS _InputOutputArray : public _OutputArray</span>
<span class="lineNum">     367 </span>            : {
<span class="lineNum">     368 </span>            : public:
<span class="lineNum">     369 </span>            :     _InputOutputArray();
<span class="lineNum">     370 </span>            :     _InputOutputArray(int _flags, void* _obj);
<span class="lineNum">     371 </span>            :     _InputOutputArray(Mat&amp; m);
<span class="lineNum">     372 </span>            :     _InputOutputArray(std::vector&lt;Mat&gt;&amp; vec);
<span class="lineNum">     373 </span>            :     _InputOutputArray(cuda::GpuMat&amp; d_mat);
<span class="lineNum">     374 </span>            :     _InputOutputArray(ogl::Buffer&amp; buf);
<span class="lineNum">     375 </span>            :     _InputOutputArray(cuda::HostMem&amp; cuda_mem);
<span class="lineNum">     376 </span>            :     template&lt;typename _Tp&gt; _InputOutputArray(cudev::GpuMat_&lt;_Tp&gt;&amp; m);
<span class="lineNum">     377 </span>            :     template&lt;typename _Tp&gt; _InputOutputArray(std::vector&lt;_Tp&gt;&amp; vec);
<span class="lineNum">     378 </span>            :     _InputOutputArray(std::vector&lt;bool&gt;&amp; vec);
<span class="lineNum">     379 </span>            :     template&lt;typename _Tp&gt; _InputOutputArray(std::vector&lt;std::vector&lt;_Tp&gt; &gt;&amp; vec);
<span class="lineNum">     380 </span>            :     template&lt;typename _Tp&gt; _InputOutputArray(std::vector&lt;Mat_&lt;_Tp&gt; &gt;&amp; vec);
<span class="lineNum">     381 </span>            :     template&lt;typename _Tp&gt; _InputOutputArray(Mat_&lt;_Tp&gt;&amp; m);
<span class="lineNum">     382 </span>            :     template&lt;typename _Tp&gt; _InputOutputArray(_Tp* vec, int n);
<span class="lineNum">     383 </span>            :     template&lt;typename _Tp, int m, int n&gt; _InputOutputArray(Matx&lt;_Tp, m, n&gt;&amp; matx);
<span class="lineNum">     384 </span>            :     _InputOutputArray(UMat&amp; m);
<span class="lineNum">     385 </span>            :     _InputOutputArray(std::vector&lt;UMat&gt;&amp; vec);
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            :     _InputOutputArray(const Mat&amp; m);
<span class="lineNum">     388 </span>            :     _InputOutputArray(const std::vector&lt;Mat&gt;&amp; vec);
<span class="lineNum">     389 </span>            :     _InputOutputArray(const cuda::GpuMat&amp; d_mat);
<span class="lineNum">     390 </span>            :     _InputOutputArray(const std::vector&lt;cuda::GpuMat&gt;&amp; d_mat);
<span class="lineNum">     391 </span>            :     _InputOutputArray(const ogl::Buffer&amp; buf);
<span class="lineNum">     392 </span>            :     _InputOutputArray(const cuda::HostMem&amp; cuda_mem);
<span class="lineNum">     393 </span>            :     template&lt;typename _Tp&gt; _InputOutputArray(const cudev::GpuMat_&lt;_Tp&gt;&amp; m);
<span class="lineNum">     394 </span>            :     template&lt;typename _Tp&gt; _InputOutputArray(const std::vector&lt;_Tp&gt;&amp; vec);
<span class="lineNum">     395 </span>            :     template&lt;typename _Tp&gt; _InputOutputArray(const std::vector&lt;std::vector&lt;_Tp&gt; &gt;&amp; vec);
<span class="lineNum">     396 </span>            :     template&lt;typename _Tp&gt; _InputOutputArray(const std::vector&lt;Mat_&lt;_Tp&gt; &gt;&amp; vec);
<span class="lineNum">     397 </span>            :     template&lt;typename _Tp&gt; _InputOutputArray(const Mat_&lt;_Tp&gt;&amp; m);
<span class="lineNum">     398 </span>            :     template&lt;typename _Tp&gt; _InputOutputArray(const _Tp* vec, int n);
<span class="lineNum">     399 </span>            :     template&lt;typename _Tp, int m, int n&gt; _InputOutputArray(const Matx&lt;_Tp, m, n&gt;&amp; matx);
<span class="lineNum">     400 </span>            :     _InputOutputArray(const UMat&amp; m);
<span class="lineNum">     401 </span>            :     _InputOutputArray(const std::vector&lt;UMat&gt;&amp; vec);
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            : #ifdef CV_CXX_STD_ARRAY
<span class="lineNum">     404 </span>            :     template&lt;typename _Tp, std::size_t _Nm&gt; _InputOutputArray(std::array&lt;_Tp, _Nm&gt;&amp; arr);
<span class="lineNum">     405 </span>            :     template&lt;typename _Tp, std::size_t _Nm&gt; _InputOutputArray(const std::array&lt;_Tp, _Nm&gt;&amp; arr);
<span class="lineNum">     406 </span>            :     template&lt;std::size_t _Nm&gt; _InputOutputArray(std::array&lt;Mat, _Nm&gt;&amp; arr);
<span class="lineNum">     407 </span>            :     template&lt;std::size_t _Nm&gt; _InputOutputArray(const std::array&lt;Mat, _Nm&gt;&amp; arr);
<span class="lineNum">     408 </span>            : #endif
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            : };
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            : CV__DEBUG_NS_END
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            : typedef const _InputArray&amp; InputArray;
<span class="lineNum">     415 </span>            : typedef InputArray InputArrayOfArrays;
<span class="lineNum">     416 </span>            : typedef const _OutputArray&amp; OutputArray;
<span class="lineNum">     417 </span>            : typedef OutputArray OutputArrayOfArrays;
<span class="lineNum">     418 </span>            : typedef const _InputOutputArray&amp; InputOutputArray;
<span class="lineNum">     419 </span>            : typedef InputOutputArray InputOutputArrayOfArrays;
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            : CV_EXPORTS InputOutputArray noArray();
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            : /////////////////////////////////// MatAllocator //////////////////////////////////////
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            : //! Usage flags for allocator
<span class="lineNum">     426 </span>            : enum UMatUsageFlags
<span class="lineNum">     427 </span>            : {
<span class="lineNum">     428 </span>            :     USAGE_DEFAULT = 0,
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :     // buffer allocation policy is platform and usage specific
<span class="lineNum">     431 </span>            :     USAGE_ALLOCATE_HOST_MEMORY = 1 &lt;&lt; 0,
<span class="lineNum">     432 </span>            :     USAGE_ALLOCATE_DEVICE_MEMORY = 1 &lt;&lt; 1,
<span class="lineNum">     433 </span>            :     USAGE_ALLOCATE_SHARED_MEMORY = 1 &lt;&lt; 2, // It is not equal to: USAGE_ALLOCATE_HOST_MEMORY | USAGE_ALLOCATE_DEVICE_MEMORY
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            :     __UMAT_USAGE_FLAGS_32BIT = 0x7fffffff // Binary compatibility hint
<span class="lineNum">     436 </span>            : };
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            : struct CV_EXPORTS UMatData;
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            : /** @brief  Custom array allocator
<span class="lineNum">     441 </span>            : */
<span class="lineNum">     442 </span>            : class CV_EXPORTS MatAllocator
<span class="lineNum">     443 </span>            : {
<span class="lineNum">     444 </span>            : public:
<span class="lineNum">     445 </span>            :     MatAllocator() {}
<span class="lineNum">     446 </span>            :     virtual ~MatAllocator() {}
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :     // let's comment it off for now to detect and fix all the uses of allocator
<span class="lineNum">     449 </span>            :     //virtual void allocate(int dims, const int* sizes, int type, int*&amp; refcount,
<span class="lineNum">     450 </span>            :     //                      uchar*&amp; datastart, uchar*&amp; data, size_t* step) = 0;
<span class="lineNum">     451 </span>            :     //virtual void deallocate(int* refcount, uchar* datastart, uchar* data) = 0;
<span class="lineNum">     452 </span>            :     virtual UMatData* allocate(int dims, const int* sizes, int type,
<span class="lineNum">     453 </span>            :                                void* data, size_t* step, int flags, UMatUsageFlags usageFlags) const = 0;
<span class="lineNum">     454 </span>            :     virtual bool allocate(UMatData* data, int accessflags, UMatUsageFlags usageFlags) const = 0;
<span class="lineNum">     455 </span>            :     virtual void deallocate(UMatData* data) const = 0;
<span class="lineNum">     456 </span>            :     virtual void map(UMatData* data, int accessflags) const;
<span class="lineNum">     457 </span>            :     virtual void unmap(UMatData* data) const;
<span class="lineNum">     458 </span>            :     virtual void download(UMatData* data, void* dst, int dims, const size_t sz[],
<span class="lineNum">     459 </span>            :                           const size_t srcofs[], const size_t srcstep[],
<span class="lineNum">     460 </span>            :                           const size_t dststep[]) const;
<span class="lineNum">     461 </span>            :     virtual void upload(UMatData* data, const void* src, int dims, const size_t sz[],
<span class="lineNum">     462 </span>            :                         const size_t dstofs[], const size_t dststep[],
<span class="lineNum">     463 </span>            :                         const size_t srcstep[]) const;
<span class="lineNum">     464 </span>            :     virtual void copy(UMatData* srcdata, UMatData* dstdata, int dims, const size_t sz[],
<span class="lineNum">     465 </span>            :                       const size_t srcofs[], const size_t srcstep[],
<span class="lineNum">     466 </span>            :                       const size_t dstofs[], const size_t dststep[], bool sync) const;
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            :     // default implementation returns DummyBufferPoolController
<span class="lineNum">     469 </span>            :     virtual BufferPoolController* getBufferPoolController(const char* id = NULL) const;
<span class="lineNum">     470 </span>            : };
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            : //////////////////////////////// MatCommaInitializer //////////////////////////////////
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            : /** @brief  Comma-separated Matrix Initializer
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :  The class instances are usually not created explicitly.
<span class="lineNum">     478 </span>            :  Instead, they are created on &quot;matrix &lt;&lt; firstValue&quot; operator.
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :  The sample below initializes 2x2 rotation matrix:
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :  \code
<span class="lineNum">     483 </span>            :  double angle = 30, a = cos(angle*CV_PI/180), b = sin(angle*CV_PI/180);
<span class="lineNum">     484 </span>            :  Mat R = (Mat_&lt;double&gt;(2,2) &lt;&lt; a, -b, b, a);
<span class="lineNum">     485 </span>            :  \endcode
<span class="lineNum">     486 </span>            : */
<span class="lineNum">     487 </span>            : template&lt;typename _Tp&gt; class MatCommaInitializer_
<span class="lineNum">     488 </span>            : {
<span class="lineNum">     489 </span>            : public:
<span class="lineNum">     490 </span>            :     //! the constructor, created by &quot;matrix &lt;&lt; firstValue&quot; operator, where matrix is cv::Mat
<span class="lineNum">     491 </span>            :     MatCommaInitializer_(Mat_&lt;_Tp&gt;* _m);
<span class="lineNum">     492 </span>            :     //! the operator that takes the next value and put it to the matrix
<span class="lineNum">     493 </span>            :     template&lt;typename T2&gt; MatCommaInitializer_&lt;_Tp&gt;&amp; operator , (T2 v);
<span class="lineNum">     494 </span>            :     //! another form of conversion operator
<span class="lineNum">     495 </span>            :     operator Mat_&lt;_Tp&gt;() const;
<span class="lineNum">     496 </span>            : protected:
<span class="lineNum">     497 </span>            :     MatIterator_&lt;_Tp&gt; it;
<span class="lineNum">     498 </span>            : };
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            : /////////////////////////////////////// Mat ///////////////////////////////////////////
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            : // note that umatdata might be allocated together
<span class="lineNum">     504 </span>            : // with the matrix data, not as a separate object.
<span class="lineNum">     505 </span>            : // therefore, it does not have constructor or destructor;
<span class="lineNum">     506 </span>            : // it should be explicitly initialized using init().
<span class="lineNum">     507 </span>            : struct CV_EXPORTS UMatData
<span class="lineNum">     508 </span>            : {
<span class="lineNum">     509 </span>            :     enum { COPY_ON_MAP=1, HOST_COPY_OBSOLETE=2,
<span class="lineNum">     510 </span>            :         DEVICE_COPY_OBSOLETE=4, TEMP_UMAT=8, TEMP_COPIED_UMAT=24,
<span class="lineNum">     511 </span>            :         USER_ALLOCATED=32, DEVICE_MEM_MAPPED=64,
<span class="lineNum">     512 </span>            :         ASYNC_CLEANUP=128
<span class="lineNum">     513 </span>            :     };
<span class="lineNum">     514 </span>            :     UMatData(const MatAllocator* allocator);
<span class="lineNum">     515 </span>            :     ~UMatData();
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            :     // provide atomic access to the structure
<span class="lineNum">     518 </span>            :     void lock();
<span class="lineNum">     519 </span>            :     void unlock();
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span>            :     bool hostCopyObsolete() const;
<span class="lineNum">     522 </span>            :     bool deviceCopyObsolete() const;
<span class="lineNum">     523 </span>            :     bool deviceMemMapped() const;
<span class="lineNum">     524 </span>            :     bool copyOnMap() const;
<span class="lineNum">     525 </span>            :     bool tempUMat() const;
<span class="lineNum">     526 </span>            :     bool tempCopiedUMat() const;
<span class="lineNum">     527 </span>            :     void markHostCopyObsolete(bool flag);
<span class="lineNum">     528 </span>            :     void markDeviceCopyObsolete(bool flag);
<span class="lineNum">     529 </span>            :     void markDeviceMemMapped(bool flag);
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            :     const MatAllocator* prevAllocator;
<span class="lineNum">     532 </span>            :     const MatAllocator* currAllocator;
<span class="lineNum">     533 </span>            :     int urefcount;
<span class="lineNum">     534 </span>            :     int refcount;
<span class="lineNum">     535 </span>            :     uchar* data;
<span class="lineNum">     536 </span>            :     uchar* origdata;
<span class="lineNum">     537 </span>            :     size_t size;
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            :     int flags;
<span class="lineNum">     540 </span>            :     void* handle;
<span class="lineNum">     541 </span>            :     void* userdata;
<span class="lineNum">     542 </span>            :     int allocatorFlags_;
<span class="lineNum">     543 </span>            :     int mapcount;
<span class="lineNum">     544 </span>            :     UMatData* originalUMatData;
<span class="lineNum">     545 </span>            : };
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span>            : struct CV_EXPORTS UMatDataAutoLock
<span class="lineNum">     549 </span>            : {
<span class="lineNum">     550 </span>            :     explicit UMatDataAutoLock(UMatData* u);
<span class="lineNum">     551 </span>            :     ~UMatDataAutoLock();
<span class="lineNum">     552 </span>            :     UMatData* u;
<span class="lineNum">     553 </span>            : };
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            : struct CV_EXPORTS MatSize
<span class="lineNum">     557 </span>            : {
<span class="lineNum">     558 </span>            :     explicit MatSize(int* _p);
<span class="lineNum">     559 </span>            :     Size operator()() const;
<span class="lineNum">     560 </span>            :     const int&amp; operator[](int i) const;
<span class="lineNum">     561 </span>            :     int&amp; operator[](int i);
<span class="lineNum">     562 </span>            :     operator const int*() const;
<span class="lineNum">     563 </span>            :     bool operator == (const MatSize&amp; sz) const;
<span class="lineNum">     564 </span>            :     bool operator != (const MatSize&amp; sz) const;
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span>            :     int* p;
<span class="lineNum">     567 </span>            : };
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            : struct CV_EXPORTS MatStep
<span class="lineNum">     570 </span>            : {
<span class="lineNum">     571 </span>            :     MatStep();
<span class="lineNum">     572 </span>            :     explicit MatStep(size_t s);
<span class="lineNum">     573 </span>            :     const size_t&amp; operator[](int i) const;
<span class="lineNum">     574 </span>            :     size_t&amp; operator[](int i);
<span class="lineNum">     575 </span>            :     operator size_t() const;
<span class="lineNum">     576 </span>            :     MatStep&amp; operator = (size_t s);
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :     size_t* p;
<span class="lineNum">     579 </span>            :     size_t buf[2];
<span class="lineNum">     580 </span>            : protected:
<span class="lineNum">     581 </span>            :     MatStep&amp; operator = (const MatStep&amp;);
<span class="lineNum">     582 </span>            : };
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            : /** @example cout_mat.cpp
<span class="lineNum">     585 </span>            : An example demonstrating the serial out capabilities of cv::Mat
<span class="lineNum">     586 </span>            : */
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            :  /** @brief n-dimensional dense array class \anchor CVMat_Details
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            : The class Mat represents an n-dimensional dense numerical single-channel or multi-channel array. It
<span class="lineNum">     591 </span>            : can be used to store real or complex-valued vectors and matrices, grayscale or color images, voxel
<span class="lineNum">     592 </span>            : volumes, vector fields, point clouds, tensors, histograms (though, very high-dimensional histograms
<span class="lineNum">     593 </span>            : may be better stored in a SparseMat ). The data layout of the array `M` is defined by the array
<span class="lineNum">     594 </span>            : `M.step[]`, so that the address of element \f$(i_0,...,i_{M.dims-1})\f$, where \f$0\leq i_k&lt;M.size[k]\f$, is
<span class="lineNum">     595 </span>            : computed as:
<span class="lineNum">     596 </span>            : \f[addr(M_{i_0,...,i_{M.dims-1}}) = M.data + M.step[0]*i_0 + M.step[1]*i_1 + ... + M.step[M.dims-1]*i_{M.dims-1}\f]
<span class="lineNum">     597 </span>            : In case of a 2-dimensional array, the above formula is reduced to:
<span class="lineNum">     598 </span>            : \f[addr(M_{i,j}) = M.data + M.step[0]*i + M.step[1]*j\f]
<span class="lineNum">     599 </span>            : Note that `M.step[i] &gt;= M.step[i+1]` (in fact, `M.step[i] &gt;= M.step[i+1]*M.size[i+1]` ). This means
<span class="lineNum">     600 </span>            : that 2-dimensional matrices are stored row-by-row, 3-dimensional matrices are stored plane-by-plane,
<span class="lineNum">     601 </span>            : and so on. M.step[M.dims-1] is minimal and always equal to the element size M.elemSize() .
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            : So, the data layout in Mat is fully compatible with CvMat, IplImage, and CvMatND types from OpenCV
<span class="lineNum">     604 </span>            : 1.x. It is also compatible with the majority of dense array types from the standard toolkits and
<span class="lineNum">     605 </span>            : SDKs, such as Numpy (ndarray), Win32 (independent device bitmaps), and others, that is, with any
<span class="lineNum">     606 </span>            : array that uses *steps* (or *strides*) to compute the position of a pixel. Due to this
<span class="lineNum">     607 </span>            : compatibility, it is possible to make a Mat header for user-allocated data and process it in-place
<span class="lineNum">     608 </span>            : using OpenCV functions.
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span>            : There are many different ways to create a Mat object. The most popular options are listed below:
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            : - Use the create(nrows, ncols, type) method or the similar Mat(nrows, ncols, type[, fillValue])
<span class="lineNum">     613 </span>            : constructor. A new array of the specified size and type is allocated. type has the same meaning as
<span class="lineNum">     614 </span>            : in the cvCreateMat method. For example, CV_8UC1 means a 8-bit single-channel array, CV_32FC2
<span class="lineNum">     615 </span>            : means a 2-channel (complex) floating-point array, and so on.
<span class="lineNum">     616 </span>            : @code
<span class="lineNum">     617 </span>            :     // make a 7x7 complex matrix filled with 1+3j.
<span class="lineNum">     618 </span>            :     Mat M(7,7,CV_32FC2,Scalar(1,3));
<span class="lineNum">     619 </span>            :     // and now turn M to a 100x60 15-channel 8-bit matrix.
<span class="lineNum">     620 </span>            :     // The old content will be deallocated
<span class="lineNum">     621 </span>            :     M.create(100,60,CV_8UC(15));
<span class="lineNum">     622 </span>            : @endcode
<span class="lineNum">     623 </span>            : As noted in the introduction to this chapter, create() allocates only a new array when the shape
<span class="lineNum">     624 </span>            : or type of the current array are different from the specified ones.
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            : - Create a multi-dimensional array:
<span class="lineNum">     627 </span>            : @code
<span class="lineNum">     628 </span>            :     // create a 100x100x100 8-bit array
<span class="lineNum">     629 </span>            :     int sz[] = {100, 100, 100};
<span class="lineNum">     630 </span>            :     Mat bigCube(3, sz, CV_8U, Scalar::all(0));
<span class="lineNum">     631 </span>            : @endcode
<span class="lineNum">     632 </span>            : It passes the number of dimensions =1 to the Mat constructor but the created array will be
<span class="lineNum">     633 </span>            : 2-dimensional with the number of columns set to 1. So, Mat::dims is always \&gt;= 2 (can also be 0
<span class="lineNum">     634 </span>            : when the array is empty).
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            : - Use a copy constructor or assignment operator where there can be an array or expression on the
<span class="lineNum">     637 </span>            : right side (see below). As noted in the introduction, the array assignment is an O(1) operation
<span class="lineNum">     638 </span>            : because it only copies the header and increases the reference counter. The Mat::clone() method can
<span class="lineNum">     639 </span>            : be used to get a full (deep) copy of the array when you need it.
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            : - Construct a header for a part of another array. It can be a single row, single column, several
<span class="lineNum">     642 </span>            : rows, several columns, rectangular region in the array (called a *minor* in algebra) or a
<span class="lineNum">     643 </span>            : diagonal. Such operations are also O(1) because the new header references the same data. You can
<span class="lineNum">     644 </span>            : actually modify a part of the array using this feature, for example:
<span class="lineNum">     645 </span>            : @code
<span class="lineNum">     646 </span>            :     // add the 5-th row, multiplied by 3 to the 3rd row
<span class="lineNum">     647 </span>            :     M.row(3) = M.row(3) + M.row(5)*3;
<span class="lineNum">     648 </span>            :     // now copy the 7-th column to the 1-st column
<span class="lineNum">     649 </span>            :     // M.col(1) = M.col(7); // this will not work
<span class="lineNum">     650 </span>            :     Mat M1 = M.col(1);
<span class="lineNum">     651 </span>            :     M.col(7).copyTo(M1);
<span class="lineNum">     652 </span>            :     // create a new 320x240 image
<span class="lineNum">     653 </span>            :     Mat img(Size(320,240),CV_8UC3);
<span class="lineNum">     654 </span>            :     // select a ROI
<span class="lineNum">     655 </span>            :     Mat roi(img, Rect(10,10,100,100));
<span class="lineNum">     656 </span>            :     // fill the ROI with (0,255,0) (which is green in RGB space);
<span class="lineNum">     657 </span>            :     // the original 320x240 image will be modified
<span class="lineNum">     658 </span>            :     roi = Scalar(0,255,0);
<span class="lineNum">     659 </span>            : @endcode
<span class="lineNum">     660 </span>            : Due to the additional datastart and dataend members, it is possible to compute a relative
<span class="lineNum">     661 </span>            : sub-array position in the main *container* array using locateROI():
<span class="lineNum">     662 </span>            : @code
<span class="lineNum">     663 </span>            :     Mat A = Mat::eye(10, 10, CV_32S);
<span class="lineNum">     664 </span>            :     // extracts A columns, 1 (inclusive) to 3 (exclusive).
<span class="lineNum">     665 </span>            :     Mat B = A(Range::all(), Range(1, 3));
<span class="lineNum">     666 </span>            :     // extracts B rows, 5 (inclusive) to 9 (exclusive).
<span class="lineNum">     667 </span>            :     // that is, C \~ A(Range(5, 9), Range(1, 3))
<span class="lineNum">     668 </span>            :     Mat C = B(Range(5, 9), Range::all());
<span class="lineNum">     669 </span>            :     Size size; Point ofs;
<span class="lineNum">     670 </span>            :     C.locateROI(size, ofs);
<span class="lineNum">     671 </span>            :     // size will be (width=10,height=10) and the ofs will be (x=1, y=5)
<span class="lineNum">     672 </span>            : @endcode
<span class="lineNum">     673 </span>            : As in case of whole matrices, if you need a deep copy, use the `clone()` method of the extracted
<span class="lineNum">     674 </span>            : sub-matrices.
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            : - Make a header for user-allocated data. It can be useful to do the following:
<span class="lineNum">     677 </span>            :     -# Process &quot;foreign&quot; data using OpenCV (for example, when you implement a DirectShow\* filter or
<span class="lineNum">     678 </span>            :     a processing module for gstreamer, and so on). For example:
<span class="lineNum">     679 </span>            :     @code
<span class="lineNum">     680 </span>            :         void process_video_frame(const unsigned char* pixels,
<span class="lineNum">     681 </span>            :                                  int width, int height, int step)
<span class="lineNum">     682 </span>            :         {
<span class="lineNum">     683 </span>            :             Mat img(height, width, CV_8UC3, pixels, step);
<span class="lineNum">     684 </span>            :             GaussianBlur(img, img, Size(7,7), 1.5, 1.5);
<span class="lineNum">     685 </span>            :         }
<span class="lineNum">     686 </span>            :     @endcode
<span class="lineNum">     687 </span>            :     -# Quickly initialize small matrices and/or get a super-fast element access.
<span class="lineNum">     688 </span>            :     @code
<span class="lineNum">     689 </span>            :         double m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};
<span class="lineNum">     690 </span>            :         Mat M = Mat(3, 3, CV_64F, m).inv();
<span class="lineNum">     691 </span>            :     @endcode
<span class="lineNum">     692 </span>            :     .
<span class="lineNum">     693 </span>            :     Partial yet very common cases of this *user-allocated data* case are conversions from CvMat and
<span class="lineNum">     694 </span>            :     IplImage to Mat. For this purpose, there is function cv::cvarrToMat taking pointers to CvMat or
<span class="lineNum">     695 </span>            :     IplImage and the optional flag indicating whether to copy the data or not.
<span class="lineNum">     696 </span>            :     @snippet samples/cpp/image.cpp iplimage
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            : - Use MATLAB-style array initializers, zeros(), ones(), eye(), for example:
<span class="lineNum">     699 </span>            : @code
<span class="lineNum">     700 </span>            :     // create a double-precision identity matrix and add it to M.
<span class="lineNum">     701 </span>            :     M += Mat::eye(M.rows, M.cols, CV_64F);
<span class="lineNum">     702 </span>            : @endcode
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            : - Use a comma-separated initializer:
<span class="lineNum">     705 </span>            : @code
<span class="lineNum">     706 </span>            :     // create a 3x3 double-precision identity matrix
<span class="lineNum">     707 </span>            :     Mat M = (Mat_&lt;double&gt;(3,3) &lt;&lt; 1, 0, 0, 0, 1, 0, 0, 0, 1);
<span class="lineNum">     708 </span>            : @endcode
<span class="lineNum">     709 </span>            : With this approach, you first call a constructor of the Mat class with the proper parameters, and
<span class="lineNum">     710 </span>            : then you just put `&lt;&lt; operator` followed by comma-separated values that can be constants,
<span class="lineNum">     711 </span>            : variables, expressions, and so on. Also, note the extra parentheses required to avoid compilation
<span class="lineNum">     712 </span>            : errors.
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span>            : Once the array is created, it is automatically managed via a reference-counting mechanism. If the
<span class="lineNum">     715 </span>            : array header is built on top of user-allocated data, you should handle the data by yourself. The
<span class="lineNum">     716 </span>            : array data is deallocated when no one points to it. If you want to release the data pointed by a
<span class="lineNum">     717 </span>            : array header before the array destructor is called, use Mat::release().
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            : The next important thing to learn about the array class is element access. This manual already
<span class="lineNum">     720 </span>            : described how to compute an address of each array element. Normally, you are not required to use the
<span class="lineNum">     721 </span>            : formula directly in the code. If you know the array element type (which can be retrieved using the
<span class="lineNum">     722 </span>            : method Mat::type() ), you can access the element \f$M_{ij}\f$ of a 2-dimensional array as:
<span class="lineNum">     723 </span>            : @code
<span class="lineNum">     724 </span>            :     M.at&lt;double&gt;(i,j) += 1.f;
<span class="lineNum">     725 </span>            : @endcode
<span class="lineNum">     726 </span>            : assuming that `M` is a double-precision floating-point array. There are several variants of the method
<span class="lineNum">     727 </span>            : at for a different number of dimensions.
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            : If you need to process a whole row of a 2D array, the most efficient way is to get the pointer to
<span class="lineNum">     730 </span>            : the row first, and then just use the plain C operator [] :
<span class="lineNum">     731 </span>            : @code
<span class="lineNum">     732 </span>            :     // compute sum of positive matrix elements
<span class="lineNum">     733 </span>            :     // (assuming that M is a double-precision matrix)
<span class="lineNum">     734 </span>            :     double sum=0;
<span class="lineNum">     735 </span>            :     for(int i = 0; i &lt; M.rows; i++)
<span class="lineNum">     736 </span>            :     {
<span class="lineNum">     737 </span>            :         const double* Mi = M.ptr&lt;double&gt;(i);
<span class="lineNum">     738 </span>            :         for(int j = 0; j &lt; M.cols; j++)
<span class="lineNum">     739 </span>            :             sum += std::max(Mi[j], 0.);
<span class="lineNum">     740 </span>            :     }
<span class="lineNum">     741 </span>            : @endcode
<span class="lineNum">     742 </span>            : Some operations, like the one above, do not actually depend on the array shape. They just process
<span class="lineNum">     743 </span>            : elements of an array one by one (or elements from multiple arrays that have the same coordinates,
<span class="lineNum">     744 </span>            : for example, array addition). Such operations are called *element-wise*. It makes sense to check
<span class="lineNum">     745 </span>            : whether all the input/output arrays are continuous, namely, have no gaps at the end of each row. If
<span class="lineNum">     746 </span>            : yes, process them as a long single row:
<span class="lineNum">     747 </span>            : @code
<span class="lineNum">     748 </span>            :     // compute the sum of positive matrix elements, optimized variant
<span class="lineNum">     749 </span>            :     double sum=0;
<span class="lineNum">     750 </span>            :     int cols = M.cols, rows = M.rows;
<span class="lineNum">     751 </span>            :     if(M.isContinuous())
<span class="lineNum">     752 </span>            :     {
<span class="lineNum">     753 </span>            :         cols *= rows;
<span class="lineNum">     754 </span>            :         rows = 1;
<span class="lineNum">     755 </span>            :     }
<span class="lineNum">     756 </span>            :     for(int i = 0; i &lt; rows; i++)
<span class="lineNum">     757 </span>            :     {
<span class="lineNum">     758 </span>            :         const double* Mi = M.ptr&lt;double&gt;(i);
<span class="lineNum">     759 </span>            :         for(int j = 0; j &lt; cols; j++)
<span class="lineNum">     760 </span>            :             sum += std::max(Mi[j], 0.);
<span class="lineNum">     761 </span>            :     }
<span class="lineNum">     762 </span>            : @endcode
<span class="lineNum">     763 </span>            : In case of the continuous matrix, the outer loop body is executed just once. So, the overhead is
<span class="lineNum">     764 </span>            : smaller, which is especially noticeable in case of small matrices.
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span>            : Finally, there are STL-style iterators that are smart enough to skip gaps between successive rows:
<span class="lineNum">     767 </span>            : @code
<span class="lineNum">     768 </span>            :     // compute sum of positive matrix elements, iterator-based variant
<span class="lineNum">     769 </span>            :     double sum=0;
<span class="lineNum">     770 </span>            :     MatConstIterator_&lt;double&gt; it = M.begin&lt;double&gt;(), it_end = M.end&lt;double&gt;();
<span class="lineNum">     771 </span>            :     for(; it != it_end; ++it)
<span class="lineNum">     772 </span>            :         sum += std::max(*it, 0.);
<span class="lineNum">     773 </span>            : @endcode
<span class="lineNum">     774 </span>            : The matrix iterators are random-access iterators, so they can be passed to any STL algorithm,
<span class="lineNum">     775 </span>            : including std::sort().
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            : @note Matrix Expressions and arithmetic see MatExpr
<span class="lineNum">     778 </span>            : */
<span class="lineNum">     779 </span>            : class CV_EXPORTS Mat
<span class="lineNum">     780 </span>            : {
<span class="lineNum">     781 </span>            : public:
<span class="lineNum">     782 </span>            :     /**
<span class="lineNum">     783 </span>            :     These are various constructors that form a matrix. As noted in the AutomaticAllocation, often
<span class="lineNum">     784 </span>            :     the default constructor is enough, and the proper matrix will be allocated by an OpenCV function.
<span class="lineNum">     785 </span>            :     The constructed matrix can further be assigned to another matrix or matrix expression or can be
<span class="lineNum">     786 </span>            :     allocated with Mat::create . In the former case, the old content is de-referenced.
<span class="lineNum">     787 </span>            :      */
<span class="lineNum">     788 </span>            :     Mat();
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            :     /** @overload
<span class="lineNum">     791 </span>            :     @param rows Number of rows in a 2D array.
<span class="lineNum">     792 </span>            :     @param cols Number of columns in a 2D array.
<span class="lineNum">     793 </span>            :     @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
<span class="lineNum">     794 </span>            :     CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
<span class="lineNum">     795 </span>            :     */
<span class="lineNum">     796 </span>            :     Mat(int rows, int cols, int type);
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            :     /** @overload
<span class="lineNum">     799 </span>            :     @param size 2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the
<span class="lineNum">     800 </span>            :     number of columns go in the reverse order.
<span class="lineNum">     801 </span>            :     @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
<span class="lineNum">     802 </span>            :     CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
<span class="lineNum">     803 </span>            :       */
<span class="lineNum">     804 </span>            :     Mat(Size size, int type);
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span>            :     /** @overload
<span class="lineNum">     807 </span>            :     @param rows Number of rows in a 2D array.
<span class="lineNum">     808 </span>            :     @param cols Number of columns in a 2D array.
<span class="lineNum">     809 </span>            :     @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
<span class="lineNum">     810 </span>            :     CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
<span class="lineNum">     811 </span>            :     @param s An optional value to initialize each matrix element with. To set all the matrix elements to
<span class="lineNum">     812 </span>            :     the particular value after the construction, use the assignment operator
<span class="lineNum">     813 </span>            :     Mat::operator=(const Scalar&amp; value) .
<span class="lineNum">     814 </span>            :     */
<span class="lineNum">     815 </span>            :     Mat(int rows, int cols, int type, const Scalar&amp; s);
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            :     /** @overload
<span class="lineNum">     818 </span>            :     @param size 2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the
<span class="lineNum">     819 </span>            :     number of columns go in the reverse order.
<span class="lineNum">     820 </span>            :     @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
<span class="lineNum">     821 </span>            :     CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
<span class="lineNum">     822 </span>            :     @param s An optional value to initialize each matrix element with. To set all the matrix elements to
<span class="lineNum">     823 </span>            :     the particular value after the construction, use the assignment operator
<span class="lineNum">     824 </span>            :     Mat::operator=(const Scalar&amp; value) .
<span class="lineNum">     825 </span>            :       */
<span class="lineNum">     826 </span>            :     Mat(Size size, int type, const Scalar&amp; s);
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            :     /** @overload
<span class="lineNum">     829 </span>            :     @param ndims Array dimensionality.
<span class="lineNum">     830 </span>            :     @param sizes Array of integers specifying an n-dimensional array shape.
<span class="lineNum">     831 </span>            :     @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
<span class="lineNum">     832 </span>            :     CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
<span class="lineNum">     833 </span>            :     */
<span class="lineNum">     834 </span>            :     Mat(int ndims, const int* sizes, int type);
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            :     /** @overload
<span class="lineNum">     837 </span>            :     @param sizes Array of integers specifying an n-dimensional array shape.
<span class="lineNum">     838 </span>            :     @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
<span class="lineNum">     839 </span>            :     CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
<span class="lineNum">     840 </span>            :     */
<span class="lineNum">     841 </span>            :     Mat(const std::vector&lt;int&gt;&amp; sizes, int type);
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            :     /** @overload
<span class="lineNum">     844 </span>            :     @param ndims Array dimensionality.
<span class="lineNum">     845 </span>            :     @param sizes Array of integers specifying an n-dimensional array shape.
<span class="lineNum">     846 </span>            :     @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
<span class="lineNum">     847 </span>            :     CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
<span class="lineNum">     848 </span>            :     @param s An optional value to initialize each matrix element with. To set all the matrix elements to
<span class="lineNum">     849 </span>            :     the particular value after the construction, use the assignment operator
<span class="lineNum">     850 </span>            :     Mat::operator=(const Scalar&amp; value) .
<span class="lineNum">     851 </span>            :     */
<span class="lineNum">     852 </span>            :     Mat(int ndims, const int* sizes, int type, const Scalar&amp; s);
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            :     /** @overload
<span class="lineNum">     855 </span>            :     @param sizes Array of integers specifying an n-dimensional array shape.
<span class="lineNum">     856 </span>            :     @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
<span class="lineNum">     857 </span>            :     CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
<span class="lineNum">     858 </span>            :     @param s An optional value to initialize each matrix element with. To set all the matrix elements to
<span class="lineNum">     859 </span>            :     the particular value after the construction, use the assignment operator
<span class="lineNum">     860 </span>            :     Mat::operator=(const Scalar&amp; value) .
<span class="lineNum">     861 </span>            :     */
<span class="lineNum">     862 </span>            :     Mat(const std::vector&lt;int&gt;&amp; sizes, int type, const Scalar&amp; s);
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span>            :     /** @overload
<span class="lineNum">     866 </span>            :     @param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied
<span class="lineNum">     867 </span>            :     by these constructors. Instead, the header pointing to m data or its sub-array is constructed and
<span class="lineNum">     868 </span>            :     associated with it. The reference counter, if any, is incremented. So, when you modify the matrix
<span class="lineNum">     869 </span>            :     formed using such a constructor, you also modify the corresponding elements of m . If you want to
<span class="lineNum">     870 </span>            :     have an independent copy of the sub-array, use Mat::clone() .
<span class="lineNum">     871 </span>            :     */
<span class="lineNum">     872 </span>            :     Mat(const Mat&amp; m);
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :     /** @overload
<span class="lineNum">     875 </span>            :     @param rows Number of rows in a 2D array.
<span class="lineNum">     876 </span>            :     @param cols Number of columns in a 2D array.
<span class="lineNum">     877 </span>            :     @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
<span class="lineNum">     878 </span>            :     CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
<span class="lineNum">     879 </span>            :     @param data Pointer to the user data. Matrix constructors that take data and step parameters do not
<span class="lineNum">     880 </span>            :     allocate matrix data. Instead, they just initialize the matrix header that points to the specified
<span class="lineNum">     881 </span>            :     data, which means that no data is copied. This operation is very efficient and can be used to
<span class="lineNum">     882 </span>            :     process external data using OpenCV functions. The external data is not automatically deallocated, so
<span class="lineNum">     883 </span>            :     you should take care of it.
<span class="lineNum">     884 </span>            :     @param step Number of bytes each matrix row occupies. The value should include the padding bytes at
<span class="lineNum">     885 </span>            :     the end of each row, if any. If the parameter is missing (set to AUTO_STEP ), no padding is assumed
<span class="lineNum">     886 </span>            :     and the actual step is calculated as cols*elemSize(). See Mat::elemSize.
<span class="lineNum">     887 </span>            :     */
<span class="lineNum">     888 </span>            :     Mat(int rows, int cols, int type, void* data, size_t step=AUTO_STEP);
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span>            :     /** @overload
<span class="lineNum">     891 </span>            :     @param size 2D array size: Size(cols, rows) . In the Size() constructor, the number of rows and the
<span class="lineNum">     892 </span>            :     number of columns go in the reverse order.
<span class="lineNum">     893 </span>            :     @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
<span class="lineNum">     894 </span>            :     CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
<span class="lineNum">     895 </span>            :     @param data Pointer to the user data. Matrix constructors that take data and step parameters do not
<span class="lineNum">     896 </span>            :     allocate matrix data. Instead, they just initialize the matrix header that points to the specified
<span class="lineNum">     897 </span>            :     data, which means that no data is copied. This operation is very efficient and can be used to
<span class="lineNum">     898 </span>            :     process external data using OpenCV functions. The external data is not automatically deallocated, so
<span class="lineNum">     899 </span>            :     you should take care of it.
<span class="lineNum">     900 </span>            :     @param step Number of bytes each matrix row occupies. The value should include the padding bytes at
<span class="lineNum">     901 </span>            :     the end of each row, if any. If the parameter is missing (set to AUTO_STEP ), no padding is assumed
<span class="lineNum">     902 </span>            :     and the actual step is calculated as cols*elemSize(). See Mat::elemSize.
<span class="lineNum">     903 </span>            :     */
<span class="lineNum">     904 </span>            :     Mat(Size size, int type, void* data, size_t step=AUTO_STEP);
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            :     /** @overload
<span class="lineNum">     907 </span>            :     @param ndims Array dimensionality.
<span class="lineNum">     908 </span>            :     @param sizes Array of integers specifying an n-dimensional array shape.
<span class="lineNum">     909 </span>            :     @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
<span class="lineNum">     910 </span>            :     CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
<span class="lineNum">     911 </span>            :     @param data Pointer to the user data. Matrix constructors that take data and step parameters do not
<span class="lineNum">     912 </span>            :     allocate matrix data. Instead, they just initialize the matrix header that points to the specified
<span class="lineNum">     913 </span>            :     data, which means that no data is copied. This operation is very efficient and can be used to
<span class="lineNum">     914 </span>            :     process external data using OpenCV functions. The external data is not automatically deallocated, so
<span class="lineNum">     915 </span>            :     you should take care of it.
<span class="lineNum">     916 </span>            :     @param steps Array of ndims-1 steps in case of a multi-dimensional array (the last step is always
<span class="lineNum">     917 </span>            :     set to the element size). If not specified, the matrix is assumed to be continuous.
<span class="lineNum">     918 </span>            :     */
<span class="lineNum">     919 </span>            :     Mat(int ndims, const int* sizes, int type, void* data, const size_t* steps=0);
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span>            :     /** @overload
<span class="lineNum">     922 </span>            :     @param sizes Array of integers specifying an n-dimensional array shape.
<span class="lineNum">     923 </span>            :     @param type Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or
<span class="lineNum">     924 </span>            :     CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.
<span class="lineNum">     925 </span>            :     @param data Pointer to the user data. Matrix constructors that take data and step parameters do not
<span class="lineNum">     926 </span>            :     allocate matrix data. Instead, they just initialize the matrix header that points to the specified
<span class="lineNum">     927 </span>            :     data, which means that no data is copied. This operation is very efficient and can be used to
<span class="lineNum">     928 </span>            :     process external data using OpenCV functions. The external data is not automatically deallocated, so
<span class="lineNum">     929 </span>            :     you should take care of it.
<span class="lineNum">     930 </span>            :     @param steps Array of ndims-1 steps in case of a multi-dimensional array (the last step is always
<span class="lineNum">     931 </span>            :     set to the element size). If not specified, the matrix is assumed to be continuous.
<span class="lineNum">     932 </span>            :     */
<span class="lineNum">     933 </span>            :     Mat(const std::vector&lt;int&gt;&amp; sizes, int type, void* data, const size_t* steps=0);
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            :     /** @overload
<span class="lineNum">     936 </span>            :     @param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied
<span class="lineNum">     937 </span>            :     by these constructors. Instead, the header pointing to m data or its sub-array is constructed and
<span class="lineNum">     938 </span>            :     associated with it. The reference counter, if any, is incremented. So, when you modify the matrix
<span class="lineNum">     939 </span>            :     formed using such a constructor, you also modify the corresponding elements of m . If you want to
<span class="lineNum">     940 </span>            :     have an independent copy of the sub-array, use Mat::clone() .
<span class="lineNum">     941 </span>            :     @param rowRange Range of the m rows to take. As usual, the range start is inclusive and the range
<span class="lineNum">     942 </span>            :     end is exclusive. Use Range::all() to take all the rows.
<span class="lineNum">     943 </span>            :     @param colRange Range of the m columns to take. Use Range::all() to take all the columns.
<span class="lineNum">     944 </span>            :     */
<span class="lineNum">     945 </span>            :     Mat(const Mat&amp; m, const Range&amp; rowRange, const Range&amp; colRange=Range::all());
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span>            :     /** @overload
<span class="lineNum">     948 </span>            :     @param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied
<span class="lineNum">     949 </span>            :     by these constructors. Instead, the header pointing to m data or its sub-array is constructed and
<span class="lineNum">     950 </span>            :     associated with it. The reference counter, if any, is incremented. So, when you modify the matrix
<span class="lineNum">     951 </span>            :     formed using such a constructor, you also modify the corresponding elements of m . If you want to
<span class="lineNum">     952 </span>            :     have an independent copy of the sub-array, use Mat::clone() .
<span class="lineNum">     953 </span>            :     @param roi Region of interest.
<span class="lineNum">     954 </span>            :     */
<span class="lineNum">     955 </span>            :     Mat(const Mat&amp; m, const Rect&amp; roi);
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            :     /** @overload
<span class="lineNum">     958 </span>            :     @param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied
<span class="lineNum">     959 </span>            :     by these constructors. Instead, the header pointing to m data or its sub-array is constructed and
<span class="lineNum">     960 </span>            :     associated with it. The reference counter, if any, is incremented. So, when you modify the matrix
<span class="lineNum">     961 </span>            :     formed using such a constructor, you also modify the corresponding elements of m . If you want to
<span class="lineNum">     962 </span>            :     have an independent copy of the sub-array, use Mat::clone() .
<span class="lineNum">     963 </span>            :     @param ranges Array of selected ranges of m along each dimensionality.
<span class="lineNum">     964 </span>            :     */
<span class="lineNum">     965 </span>            :     Mat(const Mat&amp; m, const Range* ranges);
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            :     /** @overload
<span class="lineNum">     968 </span>            :     @param m Array that (as a whole or partly) is assigned to the constructed matrix. No data is copied
<span class="lineNum">     969 </span>            :     by these constructors. Instead, the header pointing to m data or its sub-array is constructed and
<span class="lineNum">     970 </span>            :     associated with it. The reference counter, if any, is incremented. So, when you modify the matrix
<span class="lineNum">     971 </span>            :     formed using such a constructor, you also modify the corresponding elements of m . If you want to
<span class="lineNum">     972 </span>            :     have an independent copy of the sub-array, use Mat::clone() .
<span class="lineNum">     973 </span>            :     @param ranges Array of selected ranges of m along each dimensionality.
<span class="lineNum">     974 </span>            :     */
<span class="lineNum">     975 </span>            :     Mat(const Mat&amp; m, const std::vector&lt;Range&gt;&amp; ranges);
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            :     /** @overload
<span class="lineNum">     978 </span>            :     @param vec STL vector whose elements form the matrix. The matrix has a single column and the number
<span class="lineNum">     979 </span>            :     of rows equal to the number of vector elements. Type of the matrix matches the type of vector
<span class="lineNum">     980 </span>            :     elements. The constructor can handle arbitrary types, for which there is a properly declared
<span class="lineNum">     981 </span>            :     DataType . This means that the vector elements must be primitive numbers or uni-type numerical
<span class="lineNum">     982 </span>            :     tuples of numbers. Mixed-type structures are not supported. The corresponding constructor is
<span class="lineNum">     983 </span>            :     explicit. Since STL vectors are not automatically converted to Mat instances, you should write
<span class="lineNum">     984 </span>            :     Mat(vec) explicitly. Unless you copy the data into the matrix ( copyData=true ), no new elements
<span class="lineNum">     985 </span>            :     will be added to the vector because it can potentially yield vector data reallocation, and, thus,
<span class="lineNum">     986 </span>            :     the matrix data pointer will be invalid.
<span class="lineNum">     987 </span>            :     @param copyData Flag to specify whether the underlying data of the STL vector should be copied
<span class="lineNum">     988 </span>            :     to (true) or shared with (false) the newly constructed matrix. When the data is copied, the
<span class="lineNum">     989 </span>            :     allocated buffer is managed using Mat reference counting mechanism. While the data is shared,
<span class="lineNum">     990 </span>            :     the reference counter is NULL, and you should not deallocate the data until the matrix is not
<span class="lineNum">     991 </span>            :     destructed.
<span class="lineNum">     992 </span>            :     */
<span class="lineNum">     993 </span>            :     template&lt;typename _Tp&gt; explicit Mat(const std::vector&lt;_Tp&gt;&amp; vec, bool copyData=false);
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span>            : #ifdef CV_CXX11
<span class="lineNum">     996 </span>            :     /** @overload
<span class="lineNum">     997 </span>            :     */
<span class="lineNum">     998 </span>            :     template&lt;typename _Tp, typename = typename std::enable_if&lt;std::is_arithmetic&lt;_Tp&gt;::value&gt;::type&gt;
<span class="lineNum">     999 </span>            :     explicit Mat(const std::initializer_list&lt;_Tp&gt; list);
<span class="lineNum">    1000 </span>            : #endif
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span>            : #ifdef CV_CXX_STD_ARRAY
<span class="lineNum">    1003 </span>            :     /** @overload
<span class="lineNum">    1004 </span>            :     */
<span class="lineNum">    1005 </span>            :     template&lt;typename _Tp, size_t _Nm&gt; explicit Mat(const std::array&lt;_Tp, _Nm&gt;&amp; arr, bool copyData=false);
<span class="lineNum">    1006 </span>            : #endif
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            :     /** @overload
<span class="lineNum">    1009 </span>            :     */
<span class="lineNum">    1010 </span>            :     template&lt;typename _Tp, int n&gt; explicit Mat(const Vec&lt;_Tp, n&gt;&amp; vec, bool copyData=true);
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span>            :     /** @overload
<span class="lineNum">    1013 </span>            :     */
<span class="lineNum">    1014 </span>            :     template&lt;typename _Tp, int m, int n&gt; explicit Mat(const Matx&lt;_Tp, m, n&gt;&amp; mtx, bool copyData=true);
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span>            :     /** @overload
<span class="lineNum">    1017 </span>            :     */
<span class="lineNum">    1018 </span>            :     template&lt;typename _Tp&gt; explicit Mat(const Point_&lt;_Tp&gt;&amp; pt, bool copyData=true);
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span>            :     /** @overload
<span class="lineNum">    1021 </span>            :     */
<span class="lineNum">    1022 </span>            :     template&lt;typename _Tp&gt; explicit Mat(const Point3_&lt;_Tp&gt;&amp; pt, bool copyData=true);
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span>            :     /** @overload
<span class="lineNum">    1025 </span>            :     */
<span class="lineNum">    1026 </span>            :     template&lt;typename _Tp&gt; explicit Mat(const MatCommaInitializer_&lt;_Tp&gt;&amp; commaInitializer);
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            :     //! download data from GpuMat
<span class="lineNum">    1029 </span>            :     explicit Mat(const cuda::GpuMat&amp; m);
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span>            :     //! destructor - calls release()
<span class="lineNum">    1032 </span>            :     ~Mat();
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            :     /** @brief assignment operators
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span>            :     These are available assignment operators. Since they all are very different, make sure to read the
<span class="lineNum">    1037 </span>            :     operator parameters description.
<span class="lineNum">    1038 </span>            :     @param m Assigned, right-hand-side matrix. Matrix assignment is an O(1) operation. This means that
<span class="lineNum">    1039 </span>            :     no data is copied but the data is shared and the reference counter, if any, is incremented. Before
<span class="lineNum">    1040 </span>            :     assigning new data, the old data is de-referenced via Mat::release .
<span class="lineNum">    1041 </span>            :      */
<span class="lineNum">    1042 </span>            :     Mat&amp; operator = (const Mat&amp; m);
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            :     /** @overload
<span class="lineNum">    1045 </span>            :     @param expr Assigned matrix expression object. As opposite to the first form of the assignment
<span class="lineNum">    1046 </span>            :     operation, the second form can reuse already allocated matrix if it has the right size and type to
<span class="lineNum">    1047 </span>            :     fit the matrix expression result. It is automatically handled by the real function that the matrix
<span class="lineNum">    1048 </span>            :     expressions is expanded to. For example, C=A+B is expanded to add(A, B, C), and add takes care of
<span class="lineNum">    1049 </span>            :     automatic C reallocation.
<span class="lineNum">    1050 </span>            :     */
<span class="lineNum">    1051 </span>            :     Mat&amp; operator = (const MatExpr&amp; expr);
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            :     //! retrieve UMat from Mat
<span class="lineNum">    1054 </span>            :     UMat getUMat(int accessFlags, UMatUsageFlags usageFlags = USAGE_DEFAULT) const;
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span>            :     /** @brief Creates a matrix header for the specified matrix row.
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span>            :     The method makes a new header for the specified matrix row and returns it. This is an O(1)
<span class="lineNum">    1059 </span>            :     operation, regardless of the matrix size. The underlying data of the new matrix is shared with the
<span class="lineNum">    1060 </span>            :     original matrix. Here is the example of one of the classical basic matrix processing operations,
<span class="lineNum">    1061 </span>            :     axpy, used by LU and many other algorithms:
<span class="lineNum">    1062 </span>            :     @code
<span class="lineNum">    1063 </span>            :         inline void matrix_axpy(Mat&amp; A, int i, int j, double alpha)
<span class="lineNum">    1064 </span>            :         {
<span class="lineNum">    1065 </span>            :             A.row(i) += A.row(j)*alpha;
<span class="lineNum">    1066 </span>            :         }
<span class="lineNum">    1067 </span>            :     @endcode
<span class="lineNum">    1068 </span>            :     @note In the current implementation, the following code does not work as expected:
<span class="lineNum">    1069 </span>            :     @code
<span class="lineNum">    1070 </span>            :         Mat A;
<span class="lineNum">    1071 </span>            :         ...
<span class="lineNum">    1072 </span>            :         A.row(i) = A.row(j); // will not work
<span class="lineNum">    1073 </span>            :     @endcode
<span class="lineNum">    1074 </span>            :     This happens because A.row(i) forms a temporary header that is further assigned to another header.
<span class="lineNum">    1075 </span>            :     Remember that each of these operations is O(1), that is, no data is copied. Thus, the above
<span class="lineNum">    1076 </span>            :     assignment is not true if you may have expected the j-th row to be copied to the i-th row. To
<span class="lineNum">    1077 </span>            :     achieve that, you should either turn this simple assignment into an expression or use the
<span class="lineNum">    1078 </span>            :     Mat::copyTo method:
<span class="lineNum">    1079 </span>            :     @code
<span class="lineNum">    1080 </span>            :         Mat A;
<span class="lineNum">    1081 </span>            :         ...
<span class="lineNum">    1082 </span>            :         // works, but looks a bit obscure.
<span class="lineNum">    1083 </span>            :         A.row(i) = A.row(j) + 0;
<span class="lineNum">    1084 </span>            :         // this is a bit longer, but the recommended method.
<span class="lineNum">    1085 </span>            :         A.row(j).copyTo(A.row(i));
<span class="lineNum">    1086 </span>            :     @endcode
<span class="lineNum">    1087 </span>            :     @param y A 0-based row index.
<span class="lineNum">    1088 </span>            :      */
<span class="lineNum">    1089 </span>            :     Mat row(int y) const;
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span>            :     /** @brief Creates a matrix header for the specified matrix column.
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span>            :     The method makes a new header for the specified matrix column and returns it. This is an O(1)
<span class="lineNum">    1094 </span>            :     operation, regardless of the matrix size. The underlying data of the new matrix is shared with the
<span class="lineNum">    1095 </span>            :     original matrix. See also the Mat::row description.
<span class="lineNum">    1096 </span>            :     @param x A 0-based column index.
<span class="lineNum">    1097 </span>            :      */
<span class="lineNum">    1098 </span>            :     Mat col(int x) const;
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span>            :     /** @brief Creates a matrix header for the specified row span.
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span>            :     The method makes a new header for the specified row span of the matrix. Similarly to Mat::row and
<span class="lineNum">    1103 </span>            :     Mat::col , this is an O(1) operation.
<span class="lineNum">    1104 </span>            :     @param startrow An inclusive 0-based start index of the row span.
<span class="lineNum">    1105 </span>            :     @param endrow An exclusive 0-based ending index of the row span.
<span class="lineNum">    1106 </span>            :      */
<span class="lineNum">    1107 </span>            :     Mat rowRange(int startrow, int endrow) const;
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span>            :     /** @overload
<span class="lineNum">    1110 </span>            :     @param r Range structure containing both the start and the end indices.
<span class="lineNum">    1111 </span>            :     */
<span class="lineNum">    1112 </span>            :     Mat rowRange(const Range&amp; r) const;
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span>            :     /** @brief Creates a matrix header for the specified column span.
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span>            :     The method makes a new header for the specified column span of the matrix. Similarly to Mat::row and
<span class="lineNum">    1117 </span>            :     Mat::col , this is an O(1) operation.
<span class="lineNum">    1118 </span>            :     @param startcol An inclusive 0-based start index of the column span.
<span class="lineNum">    1119 </span>            :     @param endcol An exclusive 0-based ending index of the column span.
<span class="lineNum">    1120 </span>            :      */
<span class="lineNum">    1121 </span>            :     Mat colRange(int startcol, int endcol) const;
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span>            :     /** @overload
<span class="lineNum">    1124 </span>            :     @param r Range structure containing both the start and the end indices.
<span class="lineNum">    1125 </span>            :     */
<span class="lineNum">    1126 </span>            :     Mat colRange(const Range&amp; r) const;
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span>            :     /** @brief Extracts a diagonal from a matrix
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span>            :     The method makes a new header for the specified matrix diagonal. The new matrix is represented as a
<span class="lineNum">    1131 </span>            :     single-column matrix. Similarly to Mat::row and Mat::col, this is an O(1) operation.
<span class="lineNum">    1132 </span>            :     @param d index of the diagonal, with the following values:
<span class="lineNum">    1133 </span>            :     - `d=0` is the main diagonal.
<span class="lineNum">    1134 </span>            :     - `d&lt;0` is a diagonal from the lower half. For example, d=-1 means the diagonal is set
<span class="lineNum">    1135 </span>            :       immediately below the main one.
<span class="lineNum">    1136 </span>            :     - `d&gt;0` is a diagonal from the upper half. For example, d=1 means the diagonal is set
<span class="lineNum">    1137 </span>            :       immediately above the main one.
<span class="lineNum">    1138 </span>            :     For example:
<span class="lineNum">    1139 </span>            :     @code
<span class="lineNum">    1140 </span>            :         Mat m = (Mat_&lt;int&gt;(3,3) &lt;&lt;
<span class="lineNum">    1141 </span>            :                     1,2,3,
<span class="lineNum">    1142 </span>            :                     4,5,6,
<span class="lineNum">    1143 </span>            :                     7,8,9);
<span class="lineNum">    1144 </span>            :         Mat d0 = m.diag(0);
<span class="lineNum">    1145 </span>            :         Mat d1 = m.diag(1);
<span class="lineNum">    1146 </span>            :         Mat d_1 = m.diag(-1);
<span class="lineNum">    1147 </span>            :     @endcode
<span class="lineNum">    1148 </span>            :     The resulting matrices are
<span class="lineNum">    1149 </span>            :     @code
<span class="lineNum">    1150 </span>            :      d0 =
<span class="lineNum">    1151 </span>            :        [1;
<span class="lineNum">    1152 </span>            :         5;
<span class="lineNum">    1153 </span>            :         9]
<span class="lineNum">    1154 </span>            :      d1 =
<span class="lineNum">    1155 </span>            :        [2;
<span class="lineNum">    1156 </span>            :         6]
<span class="lineNum">    1157 </span>            :      d_1 =
<span class="lineNum">    1158 </span>            :        [4;
<span class="lineNum">    1159 </span>            :         8]
<span class="lineNum">    1160 </span>            :     @endcode
<span class="lineNum">    1161 </span>            :      */
<span class="lineNum">    1162 </span>            :     Mat diag(int d=0) const;
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span>            :     /** @brief creates a diagonal matrix
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span>            :     The method creates a square diagonal matrix from specified main diagonal.
<span class="lineNum">    1167 </span>            :     @param d One-dimensional matrix that represents the main diagonal.
<span class="lineNum">    1168 </span>            :      */
<span class="lineNum">    1169 </span>            :     static Mat diag(const Mat&amp; d);
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span>            :     /** @brief Creates a full copy of the array and the underlying data.
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span>            :     The method creates a full copy of the array. The original step[] is not taken into account. So, the
<span class="lineNum">    1174 </span>            :     array copy is a continuous array occupying total()*elemSize() bytes.
<span class="lineNum">    1175 </span>            :      */
<span class="lineNum">    1176 </span>            :     Mat clone() const;
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span>            :     /** @brief Copies the matrix to another one.
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span>            :     The method copies the matrix data to another matrix. Before copying the data, the method invokes :
<span class="lineNum">    1181 </span>            :     @code
<span class="lineNum">    1182 </span>            :         m.create(this-&gt;size(), this-&gt;type());
<span class="lineNum">    1183 </span>            :     @endcode
<span class="lineNum">    1184 </span>            :     so that the destination matrix is reallocated if needed. While m.copyTo(m); works flawlessly, the
<span class="lineNum">    1185 </span>            :     function does not handle the case of a partial overlap between the source and the destination
<span class="lineNum">    1186 </span>            :     matrices.
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span>            :     When the operation mask is specified, if the Mat::create call shown above reallocates the matrix,
<span class="lineNum">    1189 </span>            :     the newly allocated matrix is initialized with all zeros before copying the data.
<span class="lineNum">    1190 </span>            :     @param m Destination matrix. If it does not have a proper size or type before the operation, it is
<span class="lineNum">    1191 </span>            :     reallocated.
<span class="lineNum">    1192 </span>            :      */
<span class="lineNum">    1193 </span>            :     void copyTo( OutputArray m ) const;
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span>            :     /** @overload
<span class="lineNum">    1196 </span>            :     @param m Destination matrix. If it does not have a proper size or type before the operation, it is
<span class="lineNum">    1197 </span>            :     reallocated.
<span class="lineNum">    1198 </span>            :     @param mask Operation mask of the same size as \*this. Its non-zero elements indicate which matrix
<span class="lineNum">    1199 </span>            :     elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels.
<span class="lineNum">    1200 </span>            :     */
<span class="lineNum">    1201 </span>            :     void copyTo( OutputArray m, InputArray mask ) const;
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span>            :     /** @brief Converts an array to another data type with optional scaling.
<span class="lineNum">    1204 </span>            : 
<span class="lineNum">    1205 </span>            :     The method converts source pixel values to the target data type. saturate_cast\&lt;\&gt; is applied at
<span class="lineNum">    1206 </span>            :     the end to avoid possible overflows:
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span>            :     \f[m(x,y) = saturate \_ cast&lt;rType&gt;( \alpha (*this)(x,y) +  \beta )\f]
<span class="lineNum">    1209 </span>            :     @param m output matrix; if it does not have a proper size or type before the operation, it is
<span class="lineNum">    1210 </span>            :     reallocated.
<span class="lineNum">    1211 </span>            :     @param rtype desired output matrix type or, rather, the depth since the number of channels are the
<span class="lineNum">    1212 </span>            :     same as the input has; if rtype is negative, the output matrix will have the same type as the input.
<span class="lineNum">    1213 </span>            :     @param alpha optional scale factor.
<span class="lineNum">    1214 </span>            :     @param beta optional delta added to the scaled values.
<span class="lineNum">    1215 </span>            :      */
<span class="lineNum">    1216 </span>            :     void convertTo( OutputArray m, int rtype, double alpha=1, double beta=0 ) const;
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            :     /** @brief Provides a functional form of convertTo.
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span>            :     This is an internally used method called by the @ref MatrixExpressions engine.
<span class="lineNum">    1221 </span>            :     @param m Destination array.
<span class="lineNum">    1222 </span>            :     @param type Desired destination array depth (or -1 if it should be the same as the source type).
<span class="lineNum">    1223 </span>            :      */
<span class="lineNum">    1224 </span>            :     void assignTo( Mat&amp; m, int type=-1 ) const;
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span>            :     /** @brief Sets all or some of the array elements to the specified value.
<span class="lineNum">    1227 </span>            :     @param s Assigned scalar converted to the actual array type.
<span class="lineNum">    1228 </span>            :     */
<span class="lineNum">    1229 </span>            :     Mat&amp; operator = (const Scalar&amp; s);
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span>            :     /** @brief Sets all or some of the array elements to the specified value.
<span class="lineNum">    1232 </span>            : 
<span class="lineNum">    1233 </span>            :     This is an advanced variant of the Mat::operator=(const Scalar&amp; s) operator.
<span class="lineNum">    1234 </span>            :     @param value Assigned scalar converted to the actual array type.
<span class="lineNum">    1235 </span>            :     @param mask Operation mask of the same size as \*this. Its non-zero elements indicate which matrix
<span class="lineNum">    1236 </span>            :     elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels
<span class="lineNum">    1237 </span>            :      */
<span class="lineNum">    1238 </span>            :     Mat&amp; setTo(InputArray value, InputArray mask=noArray());
<span class="lineNum">    1239 </span>            : 
<span class="lineNum">    1240 </span>            :     /** @brief Changes the shape and/or the number of channels of a 2D matrix without copying the data.
<span class="lineNum">    1241 </span>            : 
<span class="lineNum">    1242 </span>            :     The method makes a new matrix header for \*this elements. The new matrix may have a different size
<span class="lineNum">    1243 </span>            :     and/or different number of channels. Any combination is possible if:
<span class="lineNum">    1244 </span>            :     -   No extra elements are included into the new matrix and no elements are excluded. Consequently,
<span class="lineNum">    1245 </span>            :         the product rows\*cols\*channels() must stay the same after the transformation.
<span class="lineNum">    1246 </span>            :     -   No data is copied. That is, this is an O(1) operation. Consequently, if you change the number of
<span class="lineNum">    1247 </span>            :         rows, or the operation changes the indices of elements row in some other way, the matrix must be
<span class="lineNum">    1248 </span>            :         continuous. See Mat::isContinuous .
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span>            :     For example, if there is a set of 3D points stored as an STL vector, and you want to represent the
<span class="lineNum">    1251 </span>            :     points as a 3xN matrix, do the following:
<span class="lineNum">    1252 </span>            :     @code
<span class="lineNum">    1253 </span>            :         std::vector&lt;Point3f&gt; vec;
<span class="lineNum">    1254 </span>            :         ...
<span class="lineNum">    1255 </span>            :         Mat pointMat = Mat(vec). // convert vector to Mat, O(1) operation
<span class="lineNum">    1256 </span>            :                           reshape(1). // make Nx3 1-channel matrix out of Nx1 3-channel.
<span class="lineNum">    1257 </span>            :                                       // Also, an O(1) operation
<span class="lineNum">    1258 </span>            :                              t(); // finally, transpose the Nx3 matrix.
<span class="lineNum">    1259 </span>            :                                   // This involves copying all the elements
<span class="lineNum">    1260 </span>            :     @endcode
<span class="lineNum">    1261 </span>            :     @param cn New number of channels. If the parameter is 0, the number of channels remains the same.
<span class="lineNum">    1262 </span>            :     @param rows New number of rows. If the parameter is 0, the number of rows remains the same.
<span class="lineNum">    1263 </span>            :      */
<span class="lineNum">    1264 </span>            :     Mat reshape(int cn, int rows=0) const;
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span>            :     /** @overload */
<span class="lineNum">    1267 </span>            :     Mat reshape(int cn, int newndims, const int* newsz) const;
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span>            :     /** @overload */
<span class="lineNum">    1270 </span>            :     Mat reshape(int cn, const std::vector&lt;int&gt;&amp; newshape) const;
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span>            :     /** @brief Transposes a matrix.
<span class="lineNum">    1273 </span>            : 
<span class="lineNum">    1274 </span>            :     The method performs matrix transposition by means of matrix expressions. It does not perform the
<span class="lineNum">    1275 </span>            :     actual transposition but returns a temporary matrix transposition object that can be further used as
<span class="lineNum">    1276 </span>            :     a part of more complex matrix expressions or can be assigned to a matrix:
<span class="lineNum">    1277 </span>            :     @code
<span class="lineNum">    1278 </span>            :         Mat A1 = A + Mat::eye(A.size(), A.type())*lambda;
<span class="lineNum">    1279 </span>            :         Mat C = A1.t()*A1; // compute (A + lambda*I)^t * (A + lamda*I)
<span class="lineNum">    1280 </span>            :     @endcode
<span class="lineNum">    1281 </span>            :      */
<span class="lineNum">    1282 </span>            :     MatExpr t() const;
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span>            :     /** @brief Inverses a matrix.
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span>            :     The method performs a matrix inversion by means of matrix expressions. This means that a temporary
<span class="lineNum">    1287 </span>            :     matrix inversion object is returned by the method and can be used further as a part of more complex
<span class="lineNum">    1288 </span>            :     matrix expressions or can be assigned to a matrix.
<span class="lineNum">    1289 </span>            :     @param method Matrix inversion method. One of cv::DecompTypes
<span class="lineNum">    1290 </span>            :      */
<span class="lineNum">    1291 </span>            :     MatExpr inv(int method=DECOMP_LU) const;
<span class="lineNum">    1292 </span>            : 
<span class="lineNum">    1293 </span>            :     /** @brief Performs an element-wise multiplication or division of the two matrices.
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span>            :     The method returns a temporary object encoding per-element array multiplication, with optional
<span class="lineNum">    1296 </span>            :     scale. Note that this is not a matrix multiplication that corresponds to a simpler &quot;\*&quot; operator.
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            :     Example:
<span class="lineNum">    1299 </span>            :     @code
<span class="lineNum">    1300 </span>            :         Mat C = A.mul(5/B); // equivalent to divide(A, B, C, 5)
<span class="lineNum">    1301 </span>            :     @endcode
<span class="lineNum">    1302 </span>            :     @param m Another array of the same type and the same size as \*this, or a matrix expression.
<span class="lineNum">    1303 </span>            :     @param scale Optional scale factor.
<span class="lineNum">    1304 </span>            :      */
<span class="lineNum">    1305 </span>            :     MatExpr mul(InputArray m, double scale=1) const;
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span>            :     /** @brief Computes a cross-product of two 3-element vectors.
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span>            :     The method computes a cross-product of two 3-element vectors. The vectors must be 3-element
<span class="lineNum">    1310 </span>            :     floating-point vectors of the same shape and size. The result is another 3-element vector of the
<span class="lineNum">    1311 </span>            :     same shape and type as operands.
<span class="lineNum">    1312 </span>            :     @param m Another cross-product operand.
<span class="lineNum">    1313 </span>            :      */
<span class="lineNum">    1314 </span>            :     Mat cross(InputArray m) const;
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span>            :     /** @brief Computes a dot-product of two vectors.
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span>            :     The method computes a dot-product of two matrices. If the matrices are not single-column or
<span class="lineNum">    1319 </span>            :     single-row vectors, the top-to-bottom left-to-right scan ordering is used to treat them as 1D
<span class="lineNum">    1320 </span>            :     vectors. The vectors must have the same size and type. If the matrices have more than one channel,
<span class="lineNum">    1321 </span>            :     the dot products from all the channels are summed together.
<span class="lineNum">    1322 </span>            :     @param m another dot-product operand.
<span class="lineNum">    1323 </span>            :      */
<span class="lineNum">    1324 </span>            :     double dot(InputArray m) const;
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span>            :     /** @brief Returns a zero array of the specified size and type.
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            :     The method returns a Matlab-style zero array initializer. It can be used to quickly form a constant
<span class="lineNum">    1329 </span>            :     array as a function parameter, part of a matrix expression, or as a matrix initializer. :
<span class="lineNum">    1330 </span>            :     @code
<span class="lineNum">    1331 </span>            :         Mat A;
<span class="lineNum">    1332 </span>            :         A = Mat::zeros(3, 3, CV_32F);
<span class="lineNum">    1333 </span>            :     @endcode
<span class="lineNum">    1334 </span>            :     In the example above, a new matrix is allocated only if A is not a 3x3 floating-point matrix.
<span class="lineNum">    1335 </span>            :     Otherwise, the existing matrix A is filled with zeros.
<span class="lineNum">    1336 </span>            :     @param rows Number of rows.
<span class="lineNum">    1337 </span>            :     @param cols Number of columns.
<span class="lineNum">    1338 </span>            :     @param type Created matrix type.
<span class="lineNum">    1339 </span>            :      */
<span class="lineNum">    1340 </span>            :     static MatExpr zeros(int rows, int cols, int type);
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span>            :     /** @overload
<span class="lineNum">    1343 </span>            :     @param size Alternative to the matrix size specification Size(cols, rows) .
<span class="lineNum">    1344 </span>            :     @param type Created matrix type.
<span class="lineNum">    1345 </span>            :     */
<span class="lineNum">    1346 </span>            :     static MatExpr zeros(Size size, int type);
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span>            :     /** @overload
<span class="lineNum">    1349 </span>            :     @param ndims Array dimensionality.
<span class="lineNum">    1350 </span>            :     @param sz Array of integers specifying the array shape.
<span class="lineNum">    1351 </span>            :     @param type Created matrix type.
<span class="lineNum">    1352 </span>            :     */
<span class="lineNum">    1353 </span>            :     static MatExpr zeros(int ndims, const int* sz, int type);
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span>            :     /** @brief Returns an array of all 1's of the specified size and type.
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span>            :     The method returns a Matlab-style 1's array initializer, similarly to Mat::zeros. Note that using
<span class="lineNum">    1358 </span>            :     this method you can initialize an array with an arbitrary value, using the following Matlab idiom:
<span class="lineNum">    1359 </span>            :     @code
<span class="lineNum">    1360 </span>            :         Mat A = Mat::ones(100, 100, CV_8U)*3; // make 100x100 matrix filled with 3.
<span class="lineNum">    1361 </span>            :     @endcode
<span class="lineNum">    1362 </span>            :     The above operation does not form a 100x100 matrix of 1's and then multiply it by 3. Instead, it
<span class="lineNum">    1363 </span>            :     just remembers the scale factor (3 in this case) and use it when actually invoking the matrix
<span class="lineNum">    1364 </span>            :     initializer.
<span class="lineNum">    1365 </span>            :     @param rows Number of rows.
<span class="lineNum">    1366 </span>            :     @param cols Number of columns.
<span class="lineNum">    1367 </span>            :     @param type Created matrix type.
<span class="lineNum">    1368 </span>            :      */
<span class="lineNum">    1369 </span>            :     static MatExpr ones(int rows, int cols, int type);
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span>            :     /** @overload
<span class="lineNum">    1372 </span>            :     @param size Alternative to the matrix size specification Size(cols, rows) .
<span class="lineNum">    1373 </span>            :     @param type Created matrix type.
<span class="lineNum">    1374 </span>            :     */
<span class="lineNum">    1375 </span>            :     static MatExpr ones(Size size, int type);
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span>            :     /** @overload
<span class="lineNum">    1378 </span>            :     @param ndims Array dimensionality.
<span class="lineNum">    1379 </span>            :     @param sz Array of integers specifying the array shape.
<span class="lineNum">    1380 </span>            :     @param type Created matrix type.
<span class="lineNum">    1381 </span>            :     */
<span class="lineNum">    1382 </span>            :     static MatExpr ones(int ndims, const int* sz, int type);
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span>            :     /** @brief Returns an identity matrix of the specified size and type.
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span>            :     The method returns a Matlab-style identity matrix initializer, similarly to Mat::zeros. Similarly to
<span class="lineNum">    1387 </span>            :     Mat::ones, you can use a scale operation to create a scaled identity matrix efficiently:
<span class="lineNum">    1388 </span>            :     @code
<span class="lineNum">    1389 </span>            :         // make a 4x4 diagonal matrix with 0.1's on the diagonal.
<span class="lineNum">    1390 </span>            :         Mat A = Mat::eye(4, 4, CV_32F)*0.1;
<span class="lineNum">    1391 </span>            :     @endcode
<span class="lineNum">    1392 </span>            :     @param rows Number of rows.
<span class="lineNum">    1393 </span>            :     @param cols Number of columns.
<span class="lineNum">    1394 </span>            :     @param type Created matrix type.
<span class="lineNum">    1395 </span>            :      */
<span class="lineNum">    1396 </span>            :     static MatExpr eye(int rows, int cols, int type);
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span>            :     /** @overload
<span class="lineNum">    1399 </span>            :     @param size Alternative matrix size specification as Size(cols, rows) .
<span class="lineNum">    1400 </span>            :     @param type Created matrix type.
<span class="lineNum">    1401 </span>            :     */
<span class="lineNum">    1402 </span>            :     static MatExpr eye(Size size, int type);
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span>            :     /** @brief Allocates new array data if needed.
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span>            :     This is one of the key Mat methods. Most new-style OpenCV functions and methods that produce arrays
<span class="lineNum">    1407 </span>            :     call this method for each output array. The method uses the following algorithm:
<span class="lineNum">    1408 </span>            : 
<span class="lineNum">    1409 </span>            :     -# If the current array shape and the type match the new ones, return immediately. Otherwise,
<span class="lineNum">    1410 </span>            :        de-reference the previous data by calling Mat::release.
<span class="lineNum">    1411 </span>            :     -# Initialize the new header.
<span class="lineNum">    1412 </span>            :     -# Allocate the new data of total()\*elemSize() bytes.
<span class="lineNum">    1413 </span>            :     -# Allocate the new, associated with the data, reference counter and set it to 1.
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span>            :     Such a scheme makes the memory management robust and efficient at the same time and helps avoid
<span class="lineNum">    1416 </span>            :     extra typing for you. This means that usually there is no need to explicitly allocate output arrays.
<span class="lineNum">    1417 </span>            :     That is, instead of writing:
<span class="lineNum">    1418 </span>            :     @code
<span class="lineNum">    1419 </span>            :         Mat color;
<span class="lineNum">    1420 </span>            :         ...
<span class="lineNum">    1421 </span>            :         Mat gray(color.rows, color.cols, color.depth());
<span class="lineNum">    1422 </span>            :         cvtColor(color, gray, COLOR_BGR2GRAY);
<span class="lineNum">    1423 </span>            :     @endcode
<span class="lineNum">    1424 </span>            :     you can simply write:
<span class="lineNum">    1425 </span>            :     @code
<span class="lineNum">    1426 </span>            :         Mat color;
<span class="lineNum">    1427 </span>            :         ...
<span class="lineNum">    1428 </span>            :         Mat gray;
<span class="lineNum">    1429 </span>            :         cvtColor(color, gray, COLOR_BGR2GRAY);
<span class="lineNum">    1430 </span>            :     @endcode
<span class="lineNum">    1431 </span>            :     because cvtColor, as well as the most of OpenCV functions, calls Mat::create() for the output array
<span class="lineNum">    1432 </span>            :     internally.
<span class="lineNum">    1433 </span>            :     @param rows New number of rows.
<span class="lineNum">    1434 </span>            :     @param cols New number of columns.
<span class="lineNum">    1435 </span>            :     @param type New matrix type.
<span class="lineNum">    1436 </span>            :      */
<span class="lineNum">    1437 </span>            :     void create(int rows, int cols, int type);
<span class="lineNum">    1438 </span>            : 
<span class="lineNum">    1439 </span>            :     /** @overload
<span class="lineNum">    1440 </span>            :     @param size Alternative new matrix size specification: Size(cols, rows)
<span class="lineNum">    1441 </span>            :     @param type New matrix type.
<span class="lineNum">    1442 </span>            :     */
<span class="lineNum">    1443 </span>            :     void create(Size size, int type);
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span>            :     /** @overload
<span class="lineNum">    1446 </span>            :     @param ndims New array dimensionality.
<span class="lineNum">    1447 </span>            :     @param sizes Array of integers specifying a new array shape.
<span class="lineNum">    1448 </span>            :     @param type New matrix type.
<span class="lineNum">    1449 </span>            :     */
<span class="lineNum">    1450 </span>            :     void create(int ndims, const int* sizes, int type);
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span>            :     /** @overload
<span class="lineNum">    1453 </span>            :     @param sizes Array of integers specifying a new array shape.
<span class="lineNum">    1454 </span>            :     @param type New matrix type.
<span class="lineNum">    1455 </span>            :     */
<span class="lineNum">    1456 </span>            :     void create(const std::vector&lt;int&gt;&amp; sizes, int type);
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span>            :     /** @brief Increments the reference counter.
<span class="lineNum">    1459 </span>            : 
<span class="lineNum">    1460 </span>            :     The method increments the reference counter associated with the matrix data. If the matrix header
<span class="lineNum">    1461 </span>            :     points to an external data set (see Mat::Mat ), the reference counter is NULL, and the method has no
<span class="lineNum">    1462 </span>            :     effect in this case. Normally, to avoid memory leaks, the method should not be called explicitly. It
<span class="lineNum">    1463 </span>            :     is called implicitly by the matrix assignment operator. The reference counter increment is an atomic
<span class="lineNum">    1464 </span>            :     operation on the platforms that support it. Thus, it is safe to operate on the same matrices
<span class="lineNum">    1465 </span>            :     asynchronously in different threads.
<span class="lineNum">    1466 </span>            :      */
<span class="lineNum">    1467 </span>            :     void addref();
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span>            :     /** @brief Decrements the reference counter and deallocates the matrix if needed.
<span class="lineNum">    1470 </span>            : 
<span class="lineNum">    1471 </span>            :     The method decrements the reference counter associated with the matrix data. When the reference
<span class="lineNum">    1472 </span>            :     counter reaches 0, the matrix data is deallocated and the data and the reference counter pointers
<span class="lineNum">    1473 </span>            :     are set to NULL's. If the matrix header points to an external data set (see Mat::Mat ), the
<span class="lineNum">    1474 </span>            :     reference counter is NULL, and the method has no effect in this case.
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span>            :     This method can be called manually to force the matrix data deallocation. But since this method is
<span class="lineNum">    1477 </span>            :     automatically called in the destructor, or by any other method that changes the data pointer, it is
<span class="lineNum">    1478 </span>            :     usually not needed. The reference counter decrement and check for 0 is an atomic operation on the
<span class="lineNum">    1479 </span>            :     platforms that support it. Thus, it is safe to operate on the same matrices asynchronously in
<span class="lineNum">    1480 </span>            :     different threads.
<span class="lineNum">    1481 </span>            :      */
<span class="lineNum">    1482 </span>            :     void release();
<span class="lineNum">    1483 </span>            : 
<span class="lineNum">    1484 </span>            :     //! internal use function, consider to use 'release' method instead; deallocates the matrix data
<span class="lineNum">    1485 </span>            :     void deallocate();
<span class="lineNum">    1486 </span>            :     //! internal use function; properly re-allocates _size, _step arrays
<span class="lineNum">    1487 </span>            :     void copySize(const Mat&amp; m);
<span class="lineNum">    1488 </span>            : 
<span class="lineNum">    1489 </span>            :     /** @brief Reserves space for the certain number of rows.
<span class="lineNum">    1490 </span>            : 
<span class="lineNum">    1491 </span>            :     The method reserves space for sz rows. If the matrix already has enough space to store sz rows,
<span class="lineNum">    1492 </span>            :     nothing happens. If the matrix is reallocated, the first Mat::rows rows are preserved. The method
<span class="lineNum">    1493 </span>            :     emulates the corresponding method of the STL vector class.
<span class="lineNum">    1494 </span>            :     @param sz Number of rows.
<span class="lineNum">    1495 </span>            :      */
<span class="lineNum">    1496 </span>            :     void reserve(size_t sz);
<span class="lineNum">    1497 </span>            : 
<span class="lineNum">    1498 </span>            :     /** @brief Reserves space for the certain number of bytes.
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span>            :     The method reserves space for sz bytes. If the matrix already has enough space to store sz bytes,
<span class="lineNum">    1501 </span>            :     nothing happens. If matrix has to be reallocated its previous content could be lost.
<span class="lineNum">    1502 </span>            :     @param sz Number of bytes.
<span class="lineNum">    1503 </span>            :     */
<span class="lineNum">    1504 </span>            :     void reserveBuffer(size_t sz);
<span class="lineNum">    1505 </span>            : 
<span class="lineNum">    1506 </span>            :     /** @brief Changes the number of matrix rows.
<span class="lineNum">    1507 </span>            : 
<span class="lineNum">    1508 </span>            :     The methods change the number of matrix rows. If the matrix is reallocated, the first
<span class="lineNum">    1509 </span>            :     min(Mat::rows, sz) rows are preserved. The methods emulate the corresponding methods of the STL
<span class="lineNum">    1510 </span>            :     vector class.
<span class="lineNum">    1511 </span>            :     @param sz New number of rows.
<span class="lineNum">    1512 </span>            :      */
<span class="lineNum">    1513 </span>            :     void resize(size_t sz);
<span class="lineNum">    1514 </span>            : 
<span class="lineNum">    1515 </span>            :     /** @overload
<span class="lineNum">    1516 </span>            :     @param sz New number of rows.
<span class="lineNum">    1517 </span>            :     @param s Value assigned to the newly added elements.
<span class="lineNum">    1518 </span>            :      */
<span class="lineNum">    1519 </span>            :     void resize(size_t sz, const Scalar&amp; s);
<span class="lineNum">    1520 </span>            : 
<span class="lineNum">    1521 </span>            :     //! internal function
<span class="lineNum">    1522 </span>            :     void push_back_(const void* elem);
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span>            :     /** @brief Adds elements to the bottom of the matrix.
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span>            :     The methods add one or more elements to the bottom of the matrix. They emulate the corresponding
<span class="lineNum">    1527 </span>            :     method of the STL vector class. When elem is Mat , its type and the number of columns must be the
<span class="lineNum">    1528 </span>            :     same as in the container matrix.
<span class="lineNum">    1529 </span>            :     @param elem Added element(s).
<span class="lineNum">    1530 </span>            :      */
<span class="lineNum">    1531 </span>            :     template&lt;typename _Tp&gt; void push_back(const _Tp&amp; elem);
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span>            :     /** @overload
<span class="lineNum">    1534 </span>            :     @param elem Added element(s).
<span class="lineNum">    1535 </span>            :     */
<span class="lineNum">    1536 </span>            :     template&lt;typename _Tp&gt; void push_back(const Mat_&lt;_Tp&gt;&amp; elem);
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span>            :     /** @overload
<span class="lineNum">    1539 </span>            :     @param elem Added element(s).
<span class="lineNum">    1540 </span>            :     */
<span class="lineNum">    1541 </span>            :     template&lt;typename _Tp&gt; void push_back(const std::vector&lt;_Tp&gt;&amp; elem);
<span class="lineNum">    1542 </span>            : 
<span class="lineNum">    1543 </span>            :     /** @overload
<span class="lineNum">    1544 </span>            :     @param m Added line(s).
<span class="lineNum">    1545 </span>            :     */
<span class="lineNum">    1546 </span>            :     void push_back(const Mat&amp; m);
<span class="lineNum">    1547 </span>            : 
<span class="lineNum">    1548 </span>            :     /** @brief Removes elements from the bottom of the matrix.
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span>            :     The method removes one or more rows from the bottom of the matrix.
<span class="lineNum">    1551 </span>            :     @param nelems Number of removed rows. If it is greater than the total number of rows, an exception
<span class="lineNum">    1552 </span>            :     is thrown.
<span class="lineNum">    1553 </span>            :      */
<span class="lineNum">    1554 </span>            :     void pop_back(size_t nelems=1);
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span>            :     /** @brief Locates the matrix header within a parent matrix.
<span class="lineNum">    1557 </span>            : 
<span class="lineNum">    1558 </span>            :     After you extracted a submatrix from a matrix using Mat::row, Mat::col, Mat::rowRange,
<span class="lineNum">    1559 </span>            :     Mat::colRange, and others, the resultant submatrix points just to the part of the original big
<span class="lineNum">    1560 </span>            :     matrix. However, each submatrix contains information (represented by datastart and dataend
<span class="lineNum">    1561 </span>            :     fields) that helps reconstruct the original matrix size and the position of the extracted
<span class="lineNum">    1562 </span>            :     submatrix within the original matrix. The method locateROI does exactly that.
<span class="lineNum">    1563 </span>            :     @param wholeSize Output parameter that contains the size of the whole matrix containing *this*
<span class="lineNum">    1564 </span>            :     as a part.
<span class="lineNum">    1565 </span>            :     @param ofs Output parameter that contains an offset of *this* inside the whole matrix.
<span class="lineNum">    1566 </span>            :      */
<span class="lineNum">    1567 </span>            :     void locateROI( Size&amp; wholeSize, Point&amp; ofs ) const;
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span>            :     /** @brief Adjusts a submatrix size and position within the parent matrix.
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span>            :     The method is complimentary to Mat::locateROI . The typical use of these functions is to determine
<span class="lineNum">    1572 </span>            :     the submatrix position within the parent matrix and then shift the position somehow. Typically, it
<span class="lineNum">    1573 </span>            :     can be required for filtering operations when pixels outside of the ROI should be taken into
<span class="lineNum">    1574 </span>            :     account. When all the method parameters are positive, the ROI needs to grow in all directions by the
<span class="lineNum">    1575 </span>            :     specified amount, for example:
<span class="lineNum">    1576 </span>            :     @code
<span class="lineNum">    1577 </span>            :         A.adjustROI(2, 2, 2, 2);
<span class="lineNum">    1578 </span>            :     @endcode
<span class="lineNum">    1579 </span>            :     In this example, the matrix size is increased by 4 elements in each direction. The matrix is shifted
<span class="lineNum">    1580 </span>            :     by 2 elements to the left and 2 elements up, which brings in all the necessary pixels for the
<span class="lineNum">    1581 </span>            :     filtering with the 5x5 kernel.
<span class="lineNum">    1582 </span>            : 
<span class="lineNum">    1583 </span>            :     adjustROI forces the adjusted ROI to be inside of the parent matrix that is boundaries of the
<span class="lineNum">    1584 </span>            :     adjusted ROI are constrained by boundaries of the parent matrix. For example, if the submatrix A is
<span class="lineNum">    1585 </span>            :     located in the first row of a parent matrix and you called A.adjustROI(2, 2, 2, 2) then A will not
<span class="lineNum">    1586 </span>            :     be increased in the upward direction.
<span class="lineNum">    1587 </span>            : 
<span class="lineNum">    1588 </span>            :     The function is used internally by the OpenCV filtering functions, like filter2D , morphological
<span class="lineNum">    1589 </span>            :     operations, and so on.
<span class="lineNum">    1590 </span>            :     @param dtop Shift of the top submatrix boundary upwards.
<span class="lineNum">    1591 </span>            :     @param dbottom Shift of the bottom submatrix boundary downwards.
<span class="lineNum">    1592 </span>            :     @param dleft Shift of the left submatrix boundary to the left.
<span class="lineNum">    1593 </span>            :     @param dright Shift of the right submatrix boundary to the right.
<span class="lineNum">    1594 </span>            :     @sa copyMakeBorder
<span class="lineNum">    1595 </span>            :      */
<span class="lineNum">    1596 </span>            :     Mat&amp; adjustROI( int dtop, int dbottom, int dleft, int dright );
<span class="lineNum">    1597 </span>            : 
<span class="lineNum">    1598 </span>            :     /** @brief Extracts a rectangular submatrix.
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span>            :     The operators make a new header for the specified sub-array of \*this . They are the most
<span class="lineNum">    1601 </span>            :     generalized forms of Mat::row, Mat::col, Mat::rowRange, and Mat::colRange . For example,
<span class="lineNum">    1602 </span>            :     `A(Range(0, 10), Range::all())` is equivalent to `A.rowRange(0, 10)`. Similarly to all of the above,
<span class="lineNum">    1603 </span>            :     the operators are O(1) operations, that is, no matrix data is copied.
<span class="lineNum">    1604 </span>            :     @param rowRange Start and end row of the extracted submatrix. The upper boundary is not included. To
<span class="lineNum">    1605 </span>            :     select all the rows, use Range::all().
<span class="lineNum">    1606 </span>            :     @param colRange Start and end column of the extracted submatrix. The upper boundary is not included.
<span class="lineNum">    1607 </span>            :     To select all the columns, use Range::all().
<span class="lineNum">    1608 </span>            :      */
<span class="lineNum">    1609 </span>            :     Mat operator()( Range rowRange, Range colRange ) const;
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span>            :     /** @overload
<span class="lineNum">    1612 </span>            :     @param roi Extracted submatrix specified as a rectangle.
<span class="lineNum">    1613 </span>            :     */
<span class="lineNum">    1614 </span>            :     Mat operator()( const Rect&amp; roi ) const;
<span class="lineNum">    1615 </span>            : 
<span class="lineNum">    1616 </span>            :     /** @overload
<span class="lineNum">    1617 </span>            :     @param ranges Array of selected ranges along each array dimension.
<span class="lineNum">    1618 </span>            :     */
<span class="lineNum">    1619 </span>            :     Mat operator()( const Range* ranges ) const;
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span>            :     /** @overload
<span class="lineNum">    1622 </span>            :     @param ranges Array of selected ranges along each array dimension.
<span class="lineNum">    1623 </span>            :     */
<span class="lineNum">    1624 </span>            :     Mat operator()(const std::vector&lt;Range&gt;&amp; ranges) const;
<span class="lineNum">    1625 </span>            : 
<span class="lineNum">    1626 </span>            :     // //! converts header to CvMat; no data is copied
<span class="lineNum">    1627 </span>            :     // operator CvMat() const;
<span class="lineNum">    1628 </span>            :     // //! converts header to CvMatND; no data is copied
<span class="lineNum">    1629 </span>            :     // operator CvMatND() const;
<span class="lineNum">    1630 </span>            :     // //! converts header to IplImage; no data is copied
<span class="lineNum">    1631 </span>            :     // operator IplImage() const;
<span class="lineNum">    1632 </span>            : 
<span class="lineNum">    1633 </span>            :     template&lt;typename _Tp&gt; operator std::vector&lt;_Tp&gt;() const;
<span class="lineNum">    1634 </span>            :     template&lt;typename _Tp, int n&gt; operator Vec&lt;_Tp, n&gt;() const;
<span class="lineNum">    1635 </span>            :     template&lt;typename _Tp, int m, int n&gt; operator Matx&lt;_Tp, m, n&gt;() const;
<span class="lineNum">    1636 </span>            : 
<span class="lineNum">    1637 </span>            : #ifdef CV_CXX_STD_ARRAY
<span class="lineNum">    1638 </span>            :     template&lt;typename _Tp, std::size_t _Nm&gt; operator std::array&lt;_Tp, _Nm&gt;() const;
<span class="lineNum">    1639 </span>            : #endif
<span class="lineNum">    1640 </span>            : 
<span class="lineNum">    1641 </span>            :     /** @brief Reports whether the matrix is continuous or not.
<span class="lineNum">    1642 </span>            : 
<span class="lineNum">    1643 </span>            :     The method returns true if the matrix elements are stored continuously without gaps at the end of
<span class="lineNum">    1644 </span>            :     each row. Otherwise, it returns false. Obviously, 1x1 or 1xN matrices are always continuous.
<span class="lineNum">    1645 </span>            :     Matrices created with Mat::create are always continuous. But if you extract a part of the matrix
<span class="lineNum">    1646 </span>            :     using Mat::col, Mat::diag, and so on, or constructed a matrix header for externally allocated data,
<span class="lineNum">    1647 </span>            :     such matrices may no longer have this property.
<span class="lineNum">    1648 </span>            : 
<span class="lineNum">    1649 </span>            :     The continuity flag is stored as a bit in the Mat::flags field and is computed automatically when
<span class="lineNum">    1650 </span>            :     you construct a matrix header. Thus, the continuity check is a very fast operation, though
<span class="lineNum">    1651 </span>            :     theoretically it could be done as follows:
<span class="lineNum">    1652 </span>            :     @code
<span class="lineNum">    1653 </span>            :         // alternative implementation of Mat::isContinuous()
<span class="lineNum">    1654 </span>            :         bool myCheckMatContinuity(const Mat&amp; m)
<span class="lineNum">    1655 </span>            :         {
<span class="lineNum">    1656 </span>            :             //return (m.flags &amp; Mat::CONTINUOUS_FLAG) != 0;
<span class="lineNum">    1657 </span>            :             return m.rows == 1 || m.step == m.cols*m.elemSize();
<span class="lineNum">    1658 </span>            :         }
<span class="lineNum">    1659 </span>            :     @endcode
<span class="lineNum">    1660 </span>            :     The method is used in quite a few of OpenCV functions. The point is that element-wise operations
<span class="lineNum">    1661 </span>            :     (such as arithmetic and logical operations, math functions, alpha blending, color space
<span class="lineNum">    1662 </span>            :     transformations, and others) do not depend on the image geometry. Thus, if all the input and output
<span class="lineNum">    1663 </span>            :     arrays are continuous, the functions can process them as very long single-row vectors. The example
<span class="lineNum">    1664 </span>            :     below illustrates how an alpha-blending function can be implemented:
<span class="lineNum">    1665 </span>            :     @code
<span class="lineNum">    1666 </span>            :         template&lt;typename T&gt;
<span class="lineNum">    1667 </span>            :         void alphaBlendRGBA(const Mat&amp; src1, const Mat&amp; src2, Mat&amp; dst)
<span class="lineNum">    1668 </span>            :         {
<span class="lineNum">    1669 </span>            :             const float alpha_scale = (float)std::numeric_limits&lt;T&gt;::max(),
<span class="lineNum">    1670 </span>            :                         inv_scale = 1.f/alpha_scale;
<span class="lineNum">    1671 </span>            : 
<span class="lineNum">    1672 </span>            :             CV_Assert( src1.type() == src2.type() &amp;&amp;
<span class="lineNum">    1673 </span>            :                        src1.type() == CV_MAKETYPE(traits::Depth&lt;T&gt;::value, 4) &amp;&amp;
<span class="lineNum">    1674 </span>            :                        src1.size() == src2.size());
<span class="lineNum">    1675 </span>            :             Size size = src1.size();
<span class="lineNum">    1676 </span>            :             dst.create(size, src1.type());
<span class="lineNum">    1677 </span>            : 
<span class="lineNum">    1678 </span>            :             // here is the idiom: check the arrays for continuity and,
<span class="lineNum">    1679 </span>            :             // if this is the case,
<span class="lineNum">    1680 </span>            :             // treat the arrays as 1D vectors
<span class="lineNum">    1681 </span>            :             if( src1.isContinuous() &amp;&amp; src2.isContinuous() &amp;&amp; dst.isContinuous() )
<span class="lineNum">    1682 </span>            :             {
<span class="lineNum">    1683 </span>            :                 size.width *= size.height;
<span class="lineNum">    1684 </span>            :                 size.height = 1;
<span class="lineNum">    1685 </span>            :             }
<span class="lineNum">    1686 </span>            :             size.width *= 4;
<span class="lineNum">    1687 </span>            : 
<span class="lineNum">    1688 </span>            :             for( int i = 0; i &lt; size.height; i++ )
<span class="lineNum">    1689 </span>            :             {
<span class="lineNum">    1690 </span>            :                 // when the arrays are continuous,
<span class="lineNum">    1691 </span>            :                 // the outer loop is executed only once
<span class="lineNum">    1692 </span>            :                 const T* ptr1 = src1.ptr&lt;T&gt;(i);
<span class="lineNum">    1693 </span>            :                 const T* ptr2 = src2.ptr&lt;T&gt;(i);
<span class="lineNum">    1694 </span>            :                 T* dptr = dst.ptr&lt;T&gt;(i);
<span class="lineNum">    1695 </span>            : 
<span class="lineNum">    1696 </span>            :                 for( int j = 0; j &lt; size.width; j += 4 )
<span class="lineNum">    1697 </span>            :                 {
<span class="lineNum">    1698 </span>            :                     float alpha = ptr1[j+3]*inv_scale, beta = ptr2[j+3]*inv_scale;
<span class="lineNum">    1699 </span>            :                     dptr[j] = saturate_cast&lt;T&gt;(ptr1[j]*alpha + ptr2[j]*beta);
<span class="lineNum">    1700 </span>            :                     dptr[j+1] = saturate_cast&lt;T&gt;(ptr1[j+1]*alpha + ptr2[j+1]*beta);
<span class="lineNum">    1701 </span>            :                     dptr[j+2] = saturate_cast&lt;T&gt;(ptr1[j+2]*alpha + ptr2[j+2]*beta);
<span class="lineNum">    1702 </span>            :                     dptr[j+3] = saturate_cast&lt;T&gt;((1 - (1-alpha)*(1-beta))*alpha_scale);
<span class="lineNum">    1703 </span>            :                 }
<span class="lineNum">    1704 </span>            :             }
<span class="lineNum">    1705 </span>            :         }
<span class="lineNum">    1706 </span>            :     @endcode
<span class="lineNum">    1707 </span>            :     This approach, while being very simple, can boost the performance of a simple element-operation by
<span class="lineNum">    1708 </span>            :     10-20 percents, especially if the image is rather small and the operation is quite simple.
<span class="lineNum">    1709 </span>            : 
<span class="lineNum">    1710 </span>            :     Another OpenCV idiom in this function, a call of Mat::create for the destination array, that
<span class="lineNum">    1711 </span>            :     allocates the destination array unless it already has the proper size and type. And while the newly
<span class="lineNum">    1712 </span>            :     allocated arrays are always continuous, you still need to check the destination array because
<span class="lineNum">    1713 </span>            :     Mat::create does not always allocate a new matrix.
<span class="lineNum">    1714 </span>            :      */
<span class="lineNum">    1715 </span>            :     bool isContinuous() const;
<span class="lineNum">    1716 </span>            : 
<span class="lineNum">    1717 </span>            :     //! returns true if the matrix is a submatrix of another matrix
<span class="lineNum">    1718 </span>            :     bool isSubmatrix() const;
<span class="lineNum">    1719 </span>            : 
<span class="lineNum">    1720 </span>            :     /** @brief Returns the matrix element size in bytes.
<span class="lineNum">    1721 </span>            : 
<span class="lineNum">    1722 </span>            :     The method returns the matrix element size in bytes. For example, if the matrix type is CV_16SC3 ,
<span class="lineNum">    1723 </span>            :     the method returns 3\*sizeof(short) or 6.
<span class="lineNum">    1724 </span>            :      */
<span class="lineNum">    1725 </span>            :     size_t elemSize() const;
<span class="lineNum">    1726 </span>            : 
<span class="lineNum">    1727 </span>            :     /** @brief Returns the size of each matrix element channel in bytes.
<span class="lineNum">    1728 </span>            : 
<span class="lineNum">    1729 </span>            :     The method returns the matrix element channel size in bytes, that is, it ignores the number of
<span class="lineNum">    1730 </span>            :     channels. For example, if the matrix type is CV_16SC3 , the method returns sizeof(short) or 2.
<span class="lineNum">    1731 </span>            :      */
<span class="lineNum">    1732 </span>            :     size_t elemSize1() const;
<span class="lineNum">    1733 </span>            : 
<span class="lineNum">    1734 </span>            :     /** @brief Returns the type of a matrix element.
<span class="lineNum">    1735 </span>            : 
<span class="lineNum">    1736 </span>            :     The method returns a matrix element type. This is an identifier compatible with the CvMat type
<span class="lineNum">    1737 </span>            :     system, like CV_16SC3 or 16-bit signed 3-channel array, and so on.
<span class="lineNum">    1738 </span>            :      */
<span class="lineNum">    1739 </span>            :     int type() const;
<span class="lineNum">    1740 </span>            : 
<span class="lineNum">    1741 </span>            :     /** @brief Returns the depth of a matrix element.
<span class="lineNum">    1742 </span>            : 
<span class="lineNum">    1743 </span>            :     The method returns the identifier of the matrix element depth (the type of each individual channel).
<span class="lineNum">    1744 </span>            :     For example, for a 16-bit signed element array, the method returns CV_16S . A complete list of
<span class="lineNum">    1745 </span>            :     matrix types contains the following values:
<span class="lineNum">    1746 </span>            :     -   CV_8U - 8-bit unsigned integers ( 0..255 )
<span class="lineNum">    1747 </span>            :     -   CV_8S - 8-bit signed integers ( -128..127 )
<span class="lineNum">    1748 </span>            :     -   CV_16U - 16-bit unsigned integers ( 0..65535 )
<span class="lineNum">    1749 </span>            :     -   CV_16S - 16-bit signed integers ( -32768..32767 )
<span class="lineNum">    1750 </span>            :     -   CV_32S - 32-bit signed integers ( -2147483648..2147483647 )
<span class="lineNum">    1751 </span>            :     -   CV_32F - 32-bit floating-point numbers ( -FLT_MAX..FLT_MAX, INF, NAN )
<span class="lineNum">    1752 </span>            :     -   CV_64F - 64-bit floating-point numbers ( -DBL_MAX..DBL_MAX, INF, NAN )
<span class="lineNum">    1753 </span>            :      */
<span class="lineNum">    1754 </span>            :     int depth() const;
<span class="lineNum">    1755 </span>            : 
<span class="lineNum">    1756 </span>            :     /** @brief Returns the number of matrix channels.
<span class="lineNum">    1757 </span>            : 
<span class="lineNum">    1758 </span>            :     The method returns the number of matrix channels.
<span class="lineNum">    1759 </span>            :      */
<span class="lineNum">    1760 </span>            :     int channels() const;
<span class="lineNum">    1761 </span>            : 
<span class="lineNum">    1762 </span>            :     /** @brief Returns a normalized step.
<span class="lineNum">    1763 </span>            : 
<span class="lineNum">    1764 </span>            :     The method returns a matrix step divided by Mat::elemSize1() . It can be useful to quickly access an
<span class="lineNum">    1765 </span>            :     arbitrary matrix element.
<span class="lineNum">    1766 </span>            :      */
<span class="lineNum">    1767 </span>            :     size_t step1(int i=0) const;
<span class="lineNum">    1768 </span>            : 
<span class="lineNum">    1769 </span>            :     /** @brief Returns true if the array has no elements.
<span class="lineNum">    1770 </span>            : 
<span class="lineNum">    1771 </span>            :     The method returns true if Mat::total() is 0 or if Mat::data is NULL. Because of pop_back() and
<span class="lineNum">    1772 </span>            :     resize() methods `M.total() == 0` does not imply that `M.data == NULL`.
<span class="lineNum">    1773 </span>            :      */
<span class="lineNum">    1774 </span>            :     bool empty() const;
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span>            :     /** @brief Returns the total number of array elements.
<span class="lineNum">    1777 </span>            : 
<span class="lineNum">    1778 </span>            :     The method returns the number of array elements (a number of pixels if the array represents an
<span class="lineNum">    1779 </span>            :     image).
<span class="lineNum">    1780 </span>            :      */
<span class="lineNum">    1781 </span>            :     size_t total() const;
<span class="lineNum">    1782 </span>            : 
<span class="lineNum">    1783 </span>            :     /** @brief Returns the total number of array elements.
<span class="lineNum">    1784 </span>            : 
<span class="lineNum">    1785 </span>            :      The method returns the number of elements within a certain sub-array slice with startDim &lt;= dim &lt; endDim
<span class="lineNum">    1786 </span>            :      */
<span class="lineNum">    1787 </span>            :     size_t total(int startDim, int endDim=INT_MAX) const;
<span class="lineNum">    1788 </span>            : 
<span class="lineNum">    1789 </span>            :     //! returns N if the matrix is 1-channel (N x ptdim) or ptdim-channel (1 x N) or (N x 1); negative number otherwise
<span class="lineNum">    1790 </span>            :     int checkVector(int elemChannels, int depth=-1, bool requireContinuous=true) const;
<span class="lineNum">    1791 </span>            : 
<span class="lineNum">    1792 </span>            :     /** @brief Returns a pointer to the specified matrix row.
<span class="lineNum">    1793 </span>            : 
<span class="lineNum">    1794 </span>            :     The methods return `uchar*` or typed pointer to the specified matrix row. See the sample in
<span class="lineNum">    1795 </span>            :     Mat::isContinuous to know how to use these methods.
<span class="lineNum">    1796 </span>            :     @param i0 A 0-based row index.
<span class="lineNum">    1797 </span>            :      */
<span class="lineNum">    1798 </span>            :     uchar* ptr(int i0=0);
<span class="lineNum">    1799 </span>            :     /** @overload */
<span class="lineNum">    1800 </span>            :     const uchar* ptr(int i0=0) const;
<span class="lineNum">    1801 </span>            : 
<span class="lineNum">    1802 </span>            :     /** @overload
<span class="lineNum">    1803 </span>            :     @param row Index along the dimension 0
<span class="lineNum">    1804 </span>            :     @param col Index along the dimension 1
<span class="lineNum">    1805 </span>            :     */
<span class="lineNum">    1806 </span>            :     uchar* ptr(int row, int col);
<span class="lineNum">    1807 </span>            :     /** @overload
<span class="lineNum">    1808 </span>            :     @param row Index along the dimension 0
<span class="lineNum">    1809 </span>            :     @param col Index along the dimension 1
<span class="lineNum">    1810 </span>            :     */
<span class="lineNum">    1811 </span>            :     const uchar* ptr(int row, int col) const;
<span class="lineNum">    1812 </span>            : 
<span class="lineNum">    1813 </span>            :     /** @overload */
<span class="lineNum">    1814 </span>            :     uchar* ptr(int i0, int i1, int i2);
<span class="lineNum">    1815 </span>            :     /** @overload */
<span class="lineNum">    1816 </span>            :     const uchar* ptr(int i0, int i1, int i2) const;
<span class="lineNum">    1817 </span>            : 
<span class="lineNum">    1818 </span>            :     /** @overload */
<span class="lineNum">    1819 </span>            :     uchar* ptr(const int* idx);
<span class="lineNum">    1820 </span>            :     /** @overload */
<span class="lineNum">    1821 </span>            :     const uchar* ptr(const int* idx) const;
<span class="lineNum">    1822 </span>            :     /** @overload */
<span class="lineNum">    1823 </span>            :     template&lt;int n&gt; uchar* ptr(const Vec&lt;int, n&gt;&amp; idx);
<span class="lineNum">    1824 </span>            :     /** @overload */
<span class="lineNum">    1825 </span>            :     template&lt;int n&gt; const uchar* ptr(const Vec&lt;int, n&gt;&amp; idx) const;
<span class="lineNum">    1826 </span>            : 
<span class="lineNum">    1827 </span>            :     /** @overload */
<span class="lineNum">    1828 </span>            :     template&lt;typename _Tp&gt; _Tp* ptr(int i0=0);
<span class="lineNum">    1829 </span>            :     /** @overload */
<span class="lineNum">    1830 </span>            :     template&lt;typename _Tp&gt; const _Tp* ptr(int i0=0) const;
<span class="lineNum">    1831 </span>            :     /** @overload
<span class="lineNum">    1832 </span>            :     @param row Index along the dimension 0
<span class="lineNum">    1833 </span>            :     @param col Index along the dimension 1
<span class="lineNum">    1834 </span>            :     */
<span class="lineNum">    1835 </span>            :     template&lt;typename _Tp&gt; _Tp* ptr(int row, int col);
<span class="lineNum">    1836 </span>            :     /** @overload
<span class="lineNum">    1837 </span>            :     @param row Index along the dimension 0
<span class="lineNum">    1838 </span>            :     @param col Index along the dimension 1
<span class="lineNum">    1839 </span>            :     */
<span class="lineNum">    1840 </span>            :     template&lt;typename _Tp&gt; const _Tp* ptr(int row, int col) const;
<span class="lineNum">    1841 </span>            :     /** @overload */
<span class="lineNum">    1842 </span>            :     template&lt;typename _Tp&gt; _Tp* ptr(int i0, int i1, int i2);
<span class="lineNum">    1843 </span>            :     /** @overload */
<span class="lineNum">    1844 </span>            :     template&lt;typename _Tp&gt; const _Tp* ptr(int i0, int i1, int i2) const;
<span class="lineNum">    1845 </span>            :     /** @overload */
<span class="lineNum">    1846 </span>            :     template&lt;typename _Tp&gt; _Tp* ptr(const int* idx);
<span class="lineNum">    1847 </span>            :     /** @overload */
<span class="lineNum">    1848 </span>            :     template&lt;typename _Tp&gt; const _Tp* ptr(const int* idx) const;
<span class="lineNum">    1849 </span>            :     /** @overload */
<span class="lineNum">    1850 </span>            :     template&lt;typename _Tp, int n&gt; _Tp* ptr(const Vec&lt;int, n&gt;&amp; idx);
<span class="lineNum">    1851 </span>            :     /** @overload */
<span class="lineNum">    1852 </span>            :     template&lt;typename _Tp, int n&gt; const _Tp* ptr(const Vec&lt;int, n&gt;&amp; idx) const;
<span class="lineNum">    1853 </span>            : 
<span class="lineNum">    1854 </span>            :     /** @brief Returns a reference to the specified array element.
<span class="lineNum">    1855 </span>            : 
<span class="lineNum">    1856 </span>            :     The template methods return a reference to the specified array element. For the sake of higher
<span class="lineNum">    1857 </span>            :     performance, the index range checks are only performed in the Debug configuration.
<span class="lineNum">    1858 </span>            : 
<span class="lineNum">    1859 </span>            :     Note that the variants with a single index (i) can be used to access elements of single-row or
<span class="lineNum">    1860 </span>            :     single-column 2-dimensional arrays. That is, if, for example, A is a 1 x N floating-point matrix and
<span class="lineNum">    1861 </span>            :     B is an M x 1 integer matrix, you can simply write `A.at&lt;float&gt;(k+4)` and `B.at&lt;int&gt;(2*i+1)`
<span class="lineNum">    1862 </span>            :     instead of `A.at&lt;float&gt;(0,k+4)` and `B.at&lt;int&gt;(2*i+1,0)`, respectively.
<span class="lineNum">    1863 </span>            : 
<span class="lineNum">    1864 </span>            :     The example below initializes a Hilbert matrix:
<span class="lineNum">    1865 </span>            :     @code
<span class="lineNum">    1866 </span>            :         Mat H(100, 100, CV_64F);
<span class="lineNum">    1867 </span>            :         for(int i = 0; i &lt; H.rows; i++)
<span class="lineNum">    1868 </span>            :             for(int j = 0; j &lt; H.cols; j++)
<span class="lineNum">    1869 </span>            :                 H.at&lt;double&gt;(i,j)=1./(i+j+1);
<span class="lineNum">    1870 </span>            :     @endcode
<span class="lineNum">    1871 </span>            : 
<span class="lineNum">    1872 </span>            :     Keep in mind that the size identifier used in the at operator cannot be chosen at random. It depends
<span class="lineNum">    1873 </span>            :     on the image from which you are trying to retrieve the data. The table below gives a better insight in this:
<span class="lineNum">    1874 </span>            :      - If matrix is of type `CV_8U` then use `Mat.at&lt;uchar&gt;(y,x)`.
<span class="lineNum">    1875 </span>            :      - If matrix is of type `CV_8S` then use `Mat.at&lt;schar&gt;(y,x)`.
<span class="lineNum">    1876 </span>            :      - If matrix is of type `CV_16U` then use `Mat.at&lt;ushort&gt;(y,x)`.
<span class="lineNum">    1877 </span>            :      - If matrix is of type `CV_16S` then use `Mat.at&lt;short&gt;(y,x)`.
<span class="lineNum">    1878 </span>            :      - If matrix is of type `CV_32S`  then use `Mat.at&lt;int&gt;(y,x)`.
<span class="lineNum">    1879 </span>            :      - If matrix is of type `CV_32F`  then use `Mat.at&lt;float&gt;(y,x)`.
<span class="lineNum">    1880 </span>            :      - If matrix is of type `CV_64F` then use `Mat.at&lt;double&gt;(y,x)`.
<span class="lineNum">    1881 </span>            : 
<span class="lineNum">    1882 </span>            :     @param i0 Index along the dimension 0
<span class="lineNum">    1883 </span>            :      */
<span class="lineNum">    1884 </span>            :     template&lt;typename _Tp&gt; _Tp&amp; at(int i0=0);
<span class="lineNum">    1885 </span>            :     /** @overload
<span class="lineNum">    1886 </span>            :     @param i0 Index along the dimension 0
<span class="lineNum">    1887 </span>            :     */
<span class="lineNum">    1888 </span>            :     template&lt;typename _Tp&gt; const _Tp&amp; at(int i0=0) const;
<span class="lineNum">    1889 </span>            :     /** @overload
<span class="lineNum">    1890 </span>            :     @param row Index along the dimension 0
<span class="lineNum">    1891 </span>            :     @param col Index along the dimension 1
<span class="lineNum">    1892 </span>            :     */
<span class="lineNum">    1893 </span>            :     template&lt;typename _Tp&gt; _Tp&amp; at(int row, int col);
<span class="lineNum">    1894 </span>            :     /** @overload
<span class="lineNum">    1895 </span>            :     @param row Index along the dimension 0
<span class="lineNum">    1896 </span>            :     @param col Index along the dimension 1
<span class="lineNum">    1897 </span>            :     */
<span class="lineNum">    1898 </span>            :     template&lt;typename _Tp&gt; const _Tp&amp; at(int row, int col) const;
<span class="lineNum">    1899 </span>            : 
<span class="lineNum">    1900 </span>            :     /** @overload
<span class="lineNum">    1901 </span>            :     @param i0 Index along the dimension 0
<span class="lineNum">    1902 </span>            :     @param i1 Index along the dimension 1
<span class="lineNum">    1903 </span>            :     @param i2 Index along the dimension 2
<span class="lineNum">    1904 </span>            :     */
<span class="lineNum">    1905 </span>            :     template&lt;typename _Tp&gt; _Tp&amp; at(int i0, int i1, int i2);
<span class="lineNum">    1906 </span>            :     /** @overload
<span class="lineNum">    1907 </span>            :     @param i0 Index along the dimension 0
<span class="lineNum">    1908 </span>            :     @param i1 Index along the dimension 1
<span class="lineNum">    1909 </span>            :     @param i2 Index along the dimension 2
<span class="lineNum">    1910 </span>            :     */
<span class="lineNum">    1911 </span>            :     template&lt;typename _Tp&gt; const _Tp&amp; at(int i0, int i1, int i2) const;
<span class="lineNum">    1912 </span>            : 
<span class="lineNum">    1913 </span>            :     /** @overload
<span class="lineNum">    1914 </span>            :     @param idx Array of Mat::dims indices.
<span class="lineNum">    1915 </span>            :     */
<span class="lineNum">    1916 </span>            :     template&lt;typename _Tp&gt; _Tp&amp; at(const int* idx);
<span class="lineNum">    1917 </span>            :     /** @overload
<span class="lineNum">    1918 </span>            :     @param idx Array of Mat::dims indices.
<span class="lineNum">    1919 </span>            :     */
<span class="lineNum">    1920 </span>            :     template&lt;typename _Tp&gt; const _Tp&amp; at(const int* idx) const;
<span class="lineNum">    1921 </span>            : 
<span class="lineNum">    1922 </span>            :     /** @overload */
<span class="lineNum">    1923 </span>            :     template&lt;typename _Tp, int n&gt; _Tp&amp; at(const Vec&lt;int, n&gt;&amp; idx);
<span class="lineNum">    1924 </span>            :     /** @overload */
<span class="lineNum">    1925 </span>            :     template&lt;typename _Tp, int n&gt; const _Tp&amp; at(const Vec&lt;int, n&gt;&amp; idx) const;
<span class="lineNum">    1926 </span>            : 
<span class="lineNum">    1927 </span>            :     /** @overload
<span class="lineNum">    1928 </span>            :     special versions for 2D arrays (especially convenient for referencing image pixels)
<span class="lineNum">    1929 </span>            :     @param pt Element position specified as Point(j,i) .
<span class="lineNum">    1930 </span>            :     */
<span class="lineNum">    1931 </span>            :     template&lt;typename _Tp&gt; _Tp&amp; at(Point pt);
<span class="lineNum">    1932 </span>            :     /** @overload
<span class="lineNum">    1933 </span>            :     special versions for 2D arrays (especially convenient for referencing image pixels)
<span class="lineNum">    1934 </span>            :     @param pt Element position specified as Point(j,i) .
<span class="lineNum">    1935 </span>            :     */
<span class="lineNum">    1936 </span>            :     template&lt;typename _Tp&gt; const _Tp&amp; at(Point pt) const;
<span class="lineNum">    1937 </span>            : 
<span class="lineNum">    1938 </span>            :     /** @brief Returns the matrix iterator and sets it to the first matrix element.
<span class="lineNum">    1939 </span>            : 
<span class="lineNum">    1940 </span>            :     The methods return the matrix read-only or read-write iterators. The use of matrix iterators is very
<span class="lineNum">    1941 </span>            :     similar to the use of bi-directional STL iterators. In the example below, the alpha blending
<span class="lineNum">    1942 </span>            :     function is rewritten using the matrix iterators:
<span class="lineNum">    1943 </span>            :     @code
<span class="lineNum">    1944 </span>            :         template&lt;typename T&gt;
<span class="lineNum">    1945 </span>            :         void alphaBlendRGBA(const Mat&amp; src1, const Mat&amp; src2, Mat&amp; dst)
<span class="lineNum">    1946 </span>            :         {
<span class="lineNum">    1947 </span>            :             typedef Vec&lt;T, 4&gt; VT;
<span class="lineNum">    1948 </span>            : 
<span class="lineNum">    1949 </span>            :             const float alpha_scale = (float)std::numeric_limits&lt;T&gt;::max(),
<span class="lineNum">    1950 </span>            :                         inv_scale = 1.f/alpha_scale;
<span class="lineNum">    1951 </span>            : 
<span class="lineNum">    1952 </span>            :             CV_Assert( src1.type() == src2.type() &amp;&amp;
<span class="lineNum">    1953 </span>            :                        src1.type() == traits::Type&lt;VT&gt;::value &amp;&amp;
<span class="lineNum">    1954 </span>            :                        src1.size() == src2.size());
<span class="lineNum">    1955 </span>            :             Size size = src1.size();
<span class="lineNum">    1956 </span>            :             dst.create(size, src1.type());
<span class="lineNum">    1957 </span>            : 
<span class="lineNum">    1958 </span>            :             MatConstIterator_&lt;VT&gt; it1 = src1.begin&lt;VT&gt;(), it1_end = src1.end&lt;VT&gt;();
<span class="lineNum">    1959 </span>            :             MatConstIterator_&lt;VT&gt; it2 = src2.begin&lt;VT&gt;();
<span class="lineNum">    1960 </span>            :             MatIterator_&lt;VT&gt; dst_it = dst.begin&lt;VT&gt;();
<span class="lineNum">    1961 </span>            : 
<span class="lineNum">    1962 </span>            :             for( ; it1 != it1_end; ++it1, ++it2, ++dst_it )
<span class="lineNum">    1963 </span>            :             {
<span class="lineNum">    1964 </span>            :                 VT pix1 = *it1, pix2 = *it2;
<span class="lineNum">    1965 </span>            :                 float alpha = pix1[3]*inv_scale, beta = pix2[3]*inv_scale;
<span class="lineNum">    1966 </span>            :                 *dst_it = VT(saturate_cast&lt;T&gt;(pix1[0]*alpha + pix2[0]*beta),
<span class="lineNum">    1967 </span>            :                              saturate_cast&lt;T&gt;(pix1[1]*alpha + pix2[1]*beta),
<span class="lineNum">    1968 </span>            :                              saturate_cast&lt;T&gt;(pix1[2]*alpha + pix2[2]*beta),
<span class="lineNum">    1969 </span>            :                              saturate_cast&lt;T&gt;((1 - (1-alpha)*(1-beta))*alpha_scale));
<span class="lineNum">    1970 </span>            :             }
<span class="lineNum">    1971 </span>            :         }
<span class="lineNum">    1972 </span>            :     @endcode
<span class="lineNum">    1973 </span>            :      */
<span class="lineNum">    1974 </span>            :     template&lt;typename _Tp&gt; MatIterator_&lt;_Tp&gt; begin();
<span class="lineNum">    1975 </span>            :     template&lt;typename _Tp&gt; MatConstIterator_&lt;_Tp&gt; begin() const;
<span class="lineNum">    1976 </span>            : 
<span class="lineNum">    1977 </span>            :     /** @brief Returns the matrix iterator and sets it to the after-last matrix element.
<span class="lineNum">    1978 </span>            : 
<span class="lineNum">    1979 </span>            :     The methods return the matrix read-only or read-write iterators, set to the point following the last
<span class="lineNum">    1980 </span>            :     matrix element.
<span class="lineNum">    1981 </span>            :      */
<span class="lineNum">    1982 </span>            :     template&lt;typename _Tp&gt; MatIterator_&lt;_Tp&gt; end();
<span class="lineNum">    1983 </span>            :     template&lt;typename _Tp&gt; MatConstIterator_&lt;_Tp&gt; end() const;
<span class="lineNum">    1984 </span>            : 
<span class="lineNum">    1985 </span>            :     /** @brief Runs the given functor over all matrix elements in parallel.
<span class="lineNum">    1986 </span>            : 
<span class="lineNum">    1987 </span>            :     The operation passed as argument has to be a function pointer, a function object or a lambda(C++11).
<span class="lineNum">    1988 </span>            : 
<span class="lineNum">    1989 </span>            :     Example 1. All of the operations below put 0xFF the first channel of all matrix elements:
<span class="lineNum">    1990 </span>            :     @code
<span class="lineNum">    1991 </span>            :         Mat image(1920, 1080, CV_8UC3);
<span class="lineNum">    1992 </span>            :         typedef cv::Point3_&lt;uint8_t&gt; Pixel;
<span class="lineNum">    1993 </span>            : 
<span class="lineNum">    1994 </span>            :         // first. raw pointer access.
<span class="lineNum">    1995 </span>            :         for (int r = 0; r &lt; image.rows; ++r) {
<span class="lineNum">    1996 </span>            :             Pixel* ptr = image.ptr&lt;Pixel&gt;(r, 0);
<span class="lineNum">    1997 </span>            :             const Pixel* ptr_end = ptr + image.cols;
<span class="lineNum">    1998 </span>            :             for (; ptr != ptr_end; ++ptr) {
<span class="lineNum">    1999 </span>            :                 ptr-&gt;x = 255;
<span class="lineNum">    2000 </span>            :             }
<span class="lineNum">    2001 </span>            :         }
<span class="lineNum">    2002 </span>            : 
<span class="lineNum">    2003 </span>            :         // Using MatIterator. (Simple but there are a Iterator's overhead)
<span class="lineNum">    2004 </span>            :         for (Pixel &amp;p : cv::Mat_&lt;Pixel&gt;(image)) {
<span class="lineNum">    2005 </span>            :             p.x = 255;
<span class="lineNum">    2006 </span>            :         }
<span class="lineNum">    2007 </span>            : 
<span class="lineNum">    2008 </span>            :         // Parallel execution with function object.
<span class="lineNum">    2009 </span>            :         struct Operator {
<span class="lineNum">    2010 </span>            :             void operator ()(Pixel &amp;pixel, const int * position) {
<span class="lineNum">    2011 </span>            :                 pixel.x = 255;
<span class="lineNum">    2012 </span>            :             }
<span class="lineNum">    2013 </span>            :         };
<span class="lineNum">    2014 </span>            :         image.forEach&lt;Pixel&gt;(Operator());
<span class="lineNum">    2015 </span>            : 
<span class="lineNum">    2016 </span>            :         // Parallel execution using C++11 lambda.
<span class="lineNum">    2017 </span>            :         image.forEach&lt;Pixel&gt;([](Pixel &amp;p, const int * position) -&gt; void {
<span class="lineNum">    2018 </span>            :             p.x = 255;
<span class="lineNum">    2019 </span>            :         });
<span class="lineNum">    2020 </span>            :     @endcode
<span class="lineNum">    2021 </span>            :     Example 2. Using the pixel's position:
<span class="lineNum">    2022 </span>            :     @code
<span class="lineNum">    2023 </span>            :         // Creating 3D matrix (255 x 255 x 255) typed uint8_t
<span class="lineNum">    2024 </span>            :         // and initialize all elements by the value which equals elements position.
<span class="lineNum">    2025 </span>            :         // i.e. pixels (x,y,z) = (1,2,3) is (b,g,r) = (1,2,3).
<span class="lineNum">    2026 </span>            : 
<span class="lineNum">    2027 </span>            :         int sizes[] = { 255, 255, 255 };
<span class="lineNum">    2028 </span>            :         typedef cv::Point3_&lt;uint8_t&gt; Pixel;
<span class="lineNum">    2029 </span>            : 
<span class="lineNum">    2030 </span>            :         Mat_&lt;Pixel&gt; image = Mat::zeros(3, sizes, CV_8UC3);
<span class="lineNum">    2031 </span>            : 
<span class="lineNum">    2032 </span>            :         image.forEach&lt;Pixel&gt;([&amp;](Pixel&amp; pixel, const int position[]) -&gt; void {
<span class="lineNum">    2033 </span>            :             pixel.x = position[0];
<span class="lineNum">    2034 </span>            :             pixel.y = position[1];
<span class="lineNum">    2035 </span>            :             pixel.z = position[2];
<span class="lineNum">    2036 </span>            :         });
<span class="lineNum">    2037 </span>            :     @endcode
<span class="lineNum">    2038 </span>            :      */
<span class="lineNum">    2039 </span>            :     template&lt;typename _Tp, typename Functor&gt; void forEach(const Functor&amp; operation);
<span class="lineNum">    2040 </span>            :     /** @overload */
<span class="lineNum">    2041 </span>            :     template&lt;typename _Tp, typename Functor&gt; void forEach(const Functor&amp; operation) const;
<span class="lineNum">    2042 </span>            : 
<span class="lineNum">    2043 </span>            : #ifdef CV_CXX_MOVE_SEMANTICS
<span class="lineNum">    2044 </span>            :     Mat(Mat&amp;&amp; m);
<span class="lineNum">    2045 </span>            :     Mat&amp; operator = (Mat&amp;&amp; m);
<span class="lineNum">    2046 </span>            : #endif
<span class="lineNum">    2047 </span>            : 
<span class="lineNum">    2048 </span>            :     enum { MAGIC_VAL  = 0x42FF0000, AUTO_STEP = 0, CONTINUOUS_FLAG = CV_MAT_CONT_FLAG, SUBMATRIX_FLAG = CV_SUBMAT_FLAG };
<span class="lineNum">    2049 </span>            :     enum { MAGIC_MASK = 0xFFFF0000, TYPE_MASK = 0x00000FFF, DEPTH_MASK = 7 };
<span class="lineNum">    2050 </span>            : 
<span class="lineNum">    2051 </span>            :     /*! includes several bit-fields:
<span class="lineNum">    2052 </span>            :          - the magic signature
<span class="lineNum">    2053 </span>            :          - continuity flag
<span class="lineNum">    2054 </span>            :          - depth
<span class="lineNum">    2055 </span>            :          - number of channels
<span class="lineNum">    2056 </span>            :      */
<span class="lineNum">    2057 </span>            :     int flags;
<span class="lineNum">    2058 </span>            :     //! the matrix dimensionality, &gt;= 2
<span class="lineNum">    2059 </span>            :     int dims;
<span class="lineNum">    2060 </span>            :     //! the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions
<span class="lineNum">    2061 </span>            :     int rows, cols;
<span class="lineNum">    2062 </span>            :     //! pointer to the data
<span class="lineNum">    2063 </span>            :     uchar* data;
<span class="lineNum">    2064 </span>            : 
<span class="lineNum">    2065 </span>            :     //! helper fields used in locateROI and adjustROI
<span class="lineNum">    2066 </span>            :     const uchar* datastart;
<span class="lineNum">    2067 </span>            :     const uchar* dataend;
<span class="lineNum">    2068 </span>            :     const uchar* datalimit;
<span class="lineNum">    2069 </span>            : 
<span class="lineNum">    2070 </span>            :     //! custom allocator
<span class="lineNum">    2071 </span>            :     MatAllocator* allocator;
<span class="lineNum">    2072 </span>            :     //! and the standard allocator
<span class="lineNum">    2073 </span>            :     static MatAllocator* getStdAllocator();
<span class="lineNum">    2074 </span>            :     static MatAllocator* getDefaultAllocator();
<span class="lineNum">    2075 </span>            :     static void setDefaultAllocator(MatAllocator* allocator);
<span class="lineNum">    2076 </span>            : 
<span class="lineNum">    2077 </span>            :     //! interaction with UMat
<span class="lineNum">    2078 </span>            :     UMatData* u;
<span class="lineNum">    2079 </span>            : 
<span class="lineNum">    2080 </span>            :     MatSize size;
<span class="lineNum">    2081 </span>            :     MatStep step;
<span class="lineNum">    2082 </span>            : 
<span class="lineNum">    2083 </span>            : protected:
<span class="lineNum">    2084 </span>            :     template&lt;typename _Tp, typename Functor&gt; void forEach_impl(const Functor&amp; operation);
<span class="lineNum">    2085 </span>            : };
<span class="lineNum">    2086 </span>            : 
<span class="lineNum">    2087 </span>            : 
<span class="lineNum">    2088 </span>            : ///////////////////////////////// Mat_&lt;_Tp&gt; ////////////////////////////////////
<span class="lineNum">    2089 </span>            : 
<span class="lineNum">    2090 </span>            : /** @brief Template matrix class derived from Mat
<span class="lineNum">    2091 </span>            : 
<span class="lineNum">    2092 </span>            : @code{.cpp}
<span class="lineNum">    2093 </span>            :     template&lt;typename _Tp&gt; class Mat_ : public Mat
<span class="lineNum">    2094 </span>            :     {
<span class="lineNum">    2095 </span>            :     public:
<span class="lineNum">    2096 </span>            :         // ... some specific methods
<span class="lineNum">    2097 </span>            :         //         and
<span class="lineNum">    2098 </span>            :         // no new extra fields
<span class="lineNum">    2099 </span>            :     };
<span class="lineNum">    2100 </span>            : @endcode
<span class="lineNum">    2101 </span>            : The class `Mat_&lt;_Tp&gt;` is a *thin* template wrapper on top of the Mat class. It does not have any
<span class="lineNum">    2102 </span>            : extra data fields. Nor this class nor Mat has any virtual methods. Thus, references or pointers to
<span class="lineNum">    2103 </span>            : these two classes can be freely but carefully converted one to another. For example:
<span class="lineNum">    2104 </span>            : @code{.cpp}
<span class="lineNum">    2105 </span>            :     // create a 100x100 8-bit matrix
<span class="lineNum">    2106 </span>            :     Mat M(100,100,CV_8U);
<span class="lineNum">    2107 </span>            :     // this will be compiled fine. no any data conversion will be done.
<span class="lineNum">    2108 </span>            :     Mat_&lt;float&gt;&amp; M1 = (Mat_&lt;float&gt;&amp;)M;
<span class="lineNum">    2109 </span>            :     // the program is likely to crash at the statement below
<span class="lineNum">    2110 </span>            :     M1(99,99) = 1.f;
<span class="lineNum">    2111 </span>            : @endcode
<span class="lineNum">    2112 </span>            : While Mat is sufficient in most cases, Mat_ can be more convenient if you use a lot of element
<span class="lineNum">    2113 </span>            : access operations and if you know matrix type at the compilation time. Note that
<span class="lineNum">    2114 </span>            : `Mat::at(int y,int x)` and `Mat_::operator()(int y,int x)` do absolutely the same
<span class="lineNum">    2115 </span>            : and run at the same speed, but the latter is certainly shorter:
<span class="lineNum">    2116 </span>            : @code{.cpp}
<span class="lineNum">    2117 </span>            :     Mat_&lt;double&gt; M(20,20);
<span class="lineNum">    2118 </span>            :     for(int i = 0; i &lt; M.rows; i++)
<span class="lineNum">    2119 </span>            :         for(int j = 0; j &lt; M.cols; j++)
<span class="lineNum">    2120 </span>            :             M(i,j) = 1./(i+j+1);
<span class="lineNum">    2121 </span>            :     Mat E, V;
<span class="lineNum">    2122 </span>            :     eigen(M,E,V);
<span class="lineNum">    2123 </span>            :     cout &lt;&lt; E.at&lt;double&gt;(0,0)/E.at&lt;double&gt;(M.rows-1,0);
<span class="lineNum">    2124 </span>            : @endcode
<span class="lineNum">    2125 </span>            : To use Mat_ for multi-channel images/matrices, pass Vec as a Mat_ parameter:
<span class="lineNum">    2126 </span>            : @code{.cpp}
<span class="lineNum">    2127 </span>            :     // allocate a 320x240 color image and fill it with green (in RGB space)
<span class="lineNum">    2128 </span>            :     Mat_&lt;Vec3b&gt; img(240, 320, Vec3b(0,255,0));
<span class="lineNum">    2129 </span>            :     // now draw a diagonal white line
<span class="lineNum">    2130 </span>            :     for(int i = 0; i &lt; 100; i++)
<span class="lineNum">    2131 </span>            :         img(i,i)=Vec3b(255,255,255);
<span class="lineNum">    2132 </span>            :     // and now scramble the 2nd (red) channel of each pixel
<span class="lineNum">    2133 </span>            :     for(int i = 0; i &lt; img.rows; i++)
<span class="lineNum">    2134 </span>            :         for(int j = 0; j &lt; img.cols; j++)
<span class="lineNum">    2135 </span>            :             img(i,j)[2] ^= (uchar)(i ^ j);
<span class="lineNum">    2136 </span>            : @endcode
<span class="lineNum">    2137 </span>            : Mat_ is fully compatible with C++11 range-based for loop. For example such loop
<span class="lineNum">    2138 </span>            : can be used to safely apply look-up table:
<span class="lineNum">    2139 </span>            : @code{.cpp}
<span class="lineNum">    2140 </span>            : void applyTable(Mat_&lt;uchar&gt;&amp; I, const uchar* const table)
<span class="lineNum">    2141 </span>            : {
<span class="lineNum">    2142 </span>            :     for(auto&amp; pixel : I)
<span class="lineNum">    2143 </span>            :     {
<span class="lineNum">    2144 </span>            :         pixel = table[pixel];
<span class="lineNum">    2145 </span>            :     }
<span class="lineNum">    2146 </span>            : }
<span class="lineNum">    2147 </span>            : @endcode
<span class="lineNum">    2148 </span>            :  */
<span class="lineNum">    2149 </span>            : template&lt;typename _Tp&gt; class Mat_ : public Mat
<span class="lineNum">    2150 </span>            : {
<span class="lineNum">    2151 </span>            : public:
<span class="lineNum">    2152 </span>            :     typedef _Tp value_type;
<span class="lineNum">    2153 </span>            :     typedef typename DataType&lt;_Tp&gt;::channel_type channel_type;
<span class="lineNum">    2154 </span>            :     typedef MatIterator_&lt;_Tp&gt; iterator;
<span class="lineNum">    2155 </span>            :     typedef MatConstIterator_&lt;_Tp&gt; const_iterator;
<span class="lineNum">    2156 </span>            : 
<span class="lineNum">    2157 </span>            :     //! default constructor
<span class="lineNum">    2158 </span>            :     Mat_();
<span class="lineNum">    2159 </span>            :     //! equivalent to Mat(_rows, _cols, DataType&lt;_Tp&gt;::type)
<span class="lineNum">    2160 </span>            :     Mat_(int _rows, int _cols);
<span class="lineNum">    2161 </span>            :     //! constructor that sets each matrix element to specified value
<span class="lineNum">    2162 </span>            :     Mat_(int _rows, int _cols, const _Tp&amp; value);
<span class="lineNum">    2163 </span>            :     //! equivalent to Mat(_size, DataType&lt;_Tp&gt;::type)
<span class="lineNum">    2164 </span>            :     explicit Mat_(Size _size);
<span class="lineNum">    2165 </span>            :     //! constructor that sets each matrix element to specified value
<span class="lineNum">    2166 </span>            :     Mat_(Size _size, const _Tp&amp; value);
<span class="lineNum">    2167 </span>            :     //! n-dim array constructor
<span class="lineNum">    2168 </span>            :     Mat_(int _ndims, const int* _sizes);
<span class="lineNum">    2169 </span>            :     //! n-dim array constructor that sets each matrix element to specified value
<span class="lineNum">    2170 </span>            :     Mat_(int _ndims, const int* _sizes, const _Tp&amp; value);
<span class="lineNum">    2171 </span>            :     //! copy/conversion contructor. If m is of different type, it's converted
<span class="lineNum">    2172 </span>            :     Mat_(const Mat&amp; m);
<span class="lineNum">    2173 </span>            :     //! copy constructor
<span class="lineNum">    2174 </span>            :     Mat_(const Mat_&amp; m);
<span class="lineNum">    2175 </span>            :     //! constructs a matrix on top of user-allocated data. step is in bytes(!!!), regardless of the type
<span class="lineNum">    2176 </span>            :     Mat_(int _rows, int _cols, _Tp* _data, size_t _step=AUTO_STEP);
<span class="lineNum">    2177 </span>            :     //! constructs n-dim matrix on top of user-allocated data. steps are in bytes(!!!), regardless of the type
<span class="lineNum">    2178 </span>            :     Mat_(int _ndims, const int* _sizes, _Tp* _data, const size_t* _steps=0);
<span class="lineNum">    2179 </span>            :     //! selects a submatrix
<span class="lineNum">    2180 </span>            :     Mat_(const Mat_&amp; m, const Range&amp; rowRange, const Range&amp; colRange=Range::all());
<span class="lineNum">    2181 </span>            :     //! selects a submatrix
<span class="lineNum">    2182 </span>            :     Mat_(const Mat_&amp; m, const Rect&amp; roi);
<span class="lineNum">    2183 </span>            :     //! selects a submatrix, n-dim version
<span class="lineNum">    2184 </span>            :     Mat_(const Mat_&amp; m, const Range* ranges);
<span class="lineNum">    2185 </span>            :     //! selects a submatrix, n-dim version
<span class="lineNum">    2186 </span>            :     Mat_(const Mat_&amp; m, const std::vector&lt;Range&gt;&amp; ranges);
<span class="lineNum">    2187 </span>            :     //! from a matrix expression
<span class="lineNum">    2188 </span>            :     explicit Mat_(const MatExpr&amp; e);
<span class="lineNum">    2189 </span>            :     //! makes a matrix out of Vec, std::vector, Point_ or Point3_. The matrix will have a single column
<span class="lineNum">    2190 </span>            :     explicit Mat_(const std::vector&lt;_Tp&gt;&amp; vec, bool copyData=false);
<span class="lineNum">    2191 </span>            :     template&lt;int n&gt; explicit Mat_(const Vec&lt;typename DataType&lt;_Tp&gt;::channel_type, n&gt;&amp; vec, bool copyData=true);
<span class="lineNum">    2192 </span>            :     template&lt;int m, int n&gt; explicit Mat_(const Matx&lt;typename DataType&lt;_Tp&gt;::channel_type, m, n&gt;&amp; mtx, bool copyData=true);
<span class="lineNum">    2193 </span>            :     explicit Mat_(const Point_&lt;typename DataType&lt;_Tp&gt;::channel_type&gt;&amp; pt, bool copyData=true);
<span class="lineNum">    2194 </span>            :     explicit Mat_(const Point3_&lt;typename DataType&lt;_Tp&gt;::channel_type&gt;&amp; pt, bool copyData=true);
<span class="lineNum">    2195 </span>            :     explicit Mat_(const MatCommaInitializer_&lt;_Tp&gt;&amp; commaInitializer);
<span class="lineNum">    2196 </span>            : 
<span class="lineNum">    2197 </span>            : #ifdef CV_CXX11
<span class="lineNum">    2198 </span>            :     Mat_(std::initializer_list&lt;_Tp&gt; values);
<span class="lineNum">    2199 </span>            : #endif
<span class="lineNum">    2200 </span>            : 
<span class="lineNum">    2201 </span>            : #ifdef CV_CXX_STD_ARRAY
<span class="lineNum">    2202 </span>            :     template &lt;std::size_t _Nm&gt; explicit Mat_(const std::array&lt;_Tp, _Nm&gt;&amp; arr, bool copyData=false);
<span class="lineNum">    2203 </span>            : #endif
<span class="lineNum">    2204 </span>            : 
<span class="lineNum">    2205 </span>            :     Mat_&amp; operator = (const Mat&amp; m);
<span class="lineNum">    2206 </span>            :     Mat_&amp; operator = (const Mat_&amp; m);
<span class="lineNum">    2207 </span>            :     //! set all the elements to s.
<span class="lineNum">    2208 </span>            :     Mat_&amp; operator = (const _Tp&amp; s);
<span class="lineNum">    2209 </span>            :     //! assign a matrix expression
<span class="lineNum">    2210 </span>            :     Mat_&amp; operator = (const MatExpr&amp; e);
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span>            :     //! iterators; they are smart enough to skip gaps in the end of rows
<span class="lineNum">    2213 </span>            :     iterator begin();
<span class="lineNum">    2214 </span>            :     iterator end();
<span class="lineNum">    2215 </span>            :     const_iterator begin() const;
<span class="lineNum">    2216 </span>            :     const_iterator end() const;
<span class="lineNum">    2217 </span>            : 
<span class="lineNum">    2218 </span>            :     //! template methods for for operation over all matrix elements.
<span class="lineNum">    2219 </span>            :     // the operations take care of skipping gaps in the end of rows (if any)
<span class="lineNum">    2220 </span>            :     template&lt;typename Functor&gt; void forEach(const Functor&amp; operation);
<span class="lineNum">    2221 </span>            :     template&lt;typename Functor&gt; void forEach(const Functor&amp; operation) const;
<span class="lineNum">    2222 </span>            : 
<span class="lineNum">    2223 </span>            :     //! equivalent to Mat::create(_rows, _cols, DataType&lt;_Tp&gt;::type)
<span class="lineNum">    2224 </span>            :     void create(int _rows, int _cols);
<span class="lineNum">    2225 </span>            :     //! equivalent to Mat::create(_size, DataType&lt;_Tp&gt;::type)
<span class="lineNum">    2226 </span>            :     void create(Size _size);
<span class="lineNum">    2227 </span>            :     //! equivalent to Mat::create(_ndims, _sizes, DatType&lt;_Tp&gt;::type)
<span class="lineNum">    2228 </span>            :     void create(int _ndims, const int* _sizes);
<span class="lineNum">    2229 </span>            :     //! equivalent to Mat::release()
<span class="lineNum">    2230 </span>            :     void release();
<span class="lineNum">    2231 </span>            :     //! cross-product
<span class="lineNum">    2232 </span>            :     Mat_ cross(const Mat_&amp; m) const;
<span class="lineNum">    2233 </span>            :     //! data type conversion
<span class="lineNum">    2234 </span>            :     template&lt;typename T2&gt; operator Mat_&lt;T2&gt;() const;
<span class="lineNum">    2235 </span>            :     //! overridden forms of Mat::row() etc.
<span class="lineNum">    2236 </span>            :     Mat_ row(int y) const;
<span class="lineNum">    2237 </span>            :     Mat_ col(int x) const;
<span class="lineNum">    2238 </span>            :     Mat_ diag(int d=0) const;
<span class="lineNum">    2239 </span>            :     Mat_ clone() const;
<span class="lineNum">    2240 </span>            : 
<span class="lineNum">    2241 </span>            :     //! overridden forms of Mat::elemSize() etc.
<span class="lineNum">    2242 </span>            :     size_t elemSize() const;
<span class="lineNum">    2243 </span>            :     size_t elemSize1() const;
<span class="lineNum">    2244 </span>            :     int type() const;
<span class="lineNum">    2245 </span>            :     int depth() const;
<span class="lineNum">    2246 </span>            :     int channels() const;
<span class="lineNum">    2247 </span>            :     size_t step1(int i=0) const;
<span class="lineNum">    2248 </span>            :     //! returns step()/sizeof(_Tp)
<span class="lineNum">    2249 </span>            :     size_t stepT(int i=0) const;
<span class="lineNum">    2250 </span>            : 
<span class="lineNum">    2251 </span>            :     //! overridden forms of Mat::zeros() etc. Data type is omitted, of course
<span class="lineNum">    2252 </span>            :     static MatExpr zeros(int rows, int cols);
<span class="lineNum">    2253 </span>            :     static MatExpr zeros(Size size);
<span class="lineNum">    2254 </span>            :     static MatExpr zeros(int _ndims, const int* _sizes);
<span class="lineNum">    2255 </span>            :     static MatExpr ones(int rows, int cols);
<span class="lineNum">    2256 </span>            :     static MatExpr ones(Size size);
<span class="lineNum">    2257 </span>            :     static MatExpr ones(int _ndims, const int* _sizes);
<span class="lineNum">    2258 </span>            :     static MatExpr eye(int rows, int cols);
<span class="lineNum">    2259 </span>            :     static MatExpr eye(Size size);
<span class="lineNum">    2260 </span>            : 
<span class="lineNum">    2261 </span>            :     //! some more overriden methods
<span class="lineNum">    2262 </span>            :     Mat_&amp; adjustROI( int dtop, int dbottom, int dleft, int dright );
<span class="lineNum">    2263 </span>            :     Mat_ operator()( const Range&amp; rowRange, const Range&amp; colRange ) const;
<span class="lineNum">    2264 </span>            :     Mat_ operator()( const Rect&amp; roi ) const;
<span class="lineNum">    2265 </span>            :     Mat_ operator()( const Range* ranges ) const;
<span class="lineNum">    2266 </span>            :     Mat_ operator()(const std::vector&lt;Range&gt;&amp; ranges) const;
<span class="lineNum">    2267 </span>            : 
<span class="lineNum">    2268 </span>            :     //! more convenient forms of row and element access operators
<span class="lineNum">    2269 </span>            :     _Tp* operator [](int y);
<span class="lineNum">    2270 </span>            :     const _Tp* operator [](int y) const;
<span class="lineNum">    2271 </span>            : 
<span class="lineNum">    2272 </span>            :     //! returns reference to the specified element
<span class="lineNum">    2273 </span>            :     _Tp&amp; operator ()(const int* idx);
<span class="lineNum">    2274 </span>            :     //! returns read-only reference to the specified element
<span class="lineNum">    2275 </span>            :     const _Tp&amp; operator ()(const int* idx) const;
<span class="lineNum">    2276 </span>            : 
<span class="lineNum">    2277 </span>            :     //! returns reference to the specified element
<span class="lineNum">    2278 </span>            :     template&lt;int n&gt; _Tp&amp; operator ()(const Vec&lt;int, n&gt;&amp; idx);
<span class="lineNum">    2279 </span>            :     //! returns read-only reference to the specified element
<span class="lineNum">    2280 </span>            :     template&lt;int n&gt; const _Tp&amp; operator ()(const Vec&lt;int, n&gt;&amp; idx) const;
<span class="lineNum">    2281 </span>            : 
<span class="lineNum">    2282 </span>            :     //! returns reference to the specified element (1D case)
<span class="lineNum">    2283 </span>            :     _Tp&amp; operator ()(int idx0);
<span class="lineNum">    2284 </span>            :     //! returns read-only reference to the specified element (1D case)
<span class="lineNum">    2285 </span>            :     const _Tp&amp; operator ()(int idx0) const;
<span class="lineNum">    2286 </span>            :     //! returns reference to the specified element (2D case)
<span class="lineNum">    2287 </span>            :     _Tp&amp; operator ()(int row, int col);
<span class="lineNum">    2288 </span>            :     //! returns read-only reference to the specified element (2D case)
<span class="lineNum">    2289 </span>            :     const _Tp&amp; operator ()(int row, int col) const;
<span class="lineNum">    2290 </span>            :     //! returns reference to the specified element (3D case)
<span class="lineNum">    2291 </span>            :     _Tp&amp; operator ()(int idx0, int idx1, int idx2);
<span class="lineNum">    2292 </span>            :     //! returns read-only reference to the specified element (3D case)
<span class="lineNum">    2293 </span>            :     const _Tp&amp; operator ()(int idx0, int idx1, int idx2) const;
<span class="lineNum">    2294 </span>            : 
<span class="lineNum">    2295 </span>            :     _Tp&amp; operator ()(Point pt);
<span class="lineNum">    2296 </span>            :     const _Tp&amp; operator ()(Point pt) const;
<span class="lineNum">    2297 </span>            : 
<span class="lineNum">    2298 </span>            :     //! conversion to vector.
<span class="lineNum">    2299 </span>            :     operator std::vector&lt;_Tp&gt;() const;
<span class="lineNum">    2300 </span>            : 
<span class="lineNum">    2301 </span>            : #ifdef CV_CXX_STD_ARRAY
<span class="lineNum">    2302 </span>            :     //! conversion to array.
<span class="lineNum">    2303 </span>            :     template&lt;std::size_t _Nm&gt; operator std::array&lt;_Tp, _Nm&gt;() const;
<span class="lineNum">    2304 </span>            : #endif
<span class="lineNum">    2305 </span>            : 
<span class="lineNum">    2306 </span>            :     //! conversion to Vec
<span class="lineNum">    2307 </span>            :     template&lt;int n&gt; operator Vec&lt;typename DataType&lt;_Tp&gt;::channel_type, n&gt;() const;
<span class="lineNum">    2308 </span>            :     //! conversion to Matx
<span class="lineNum">    2309 </span>            :     template&lt;int m, int n&gt; operator Matx&lt;typename DataType&lt;_Tp&gt;::channel_type, m, n&gt;() const;
<span class="lineNum">    2310 </span>            : 
<span class="lineNum">    2311 </span>            : #ifdef CV_CXX_MOVE_SEMANTICS
<span class="lineNum">    2312 </span>            :     Mat_(Mat_&amp;&amp; m);
<span class="lineNum">    2313 </span>            :     Mat_&amp; operator = (Mat_&amp;&amp; m);
<span class="lineNum">    2314 </span>            : 
<span class="lineNum">    2315 </span>            :     Mat_(Mat&amp;&amp; m);
<span class="lineNum">    2316 </span>            :     Mat_&amp; operator = (Mat&amp;&amp; m);
<span class="lineNum">    2317 </span>            : 
<span class="lineNum">    2318 </span>            :     Mat_(MatExpr&amp;&amp; e);
<span class="lineNum">    2319 </span>            : #endif
<span class="lineNum">    2320 </span>            : };
<span class="lineNum">    2321 </span>            : 
<span class="lineNum">    2322 </span>            : typedef Mat_&lt;uchar&gt; Mat1b;
<span class="lineNum">    2323 </span>            : typedef Mat_&lt;Vec2b&gt; Mat2b;
<span class="lineNum">    2324 </span>            : typedef Mat_&lt;Vec3b&gt; Mat3b;
<span class="lineNum">    2325 </span>            : typedef Mat_&lt;Vec4b&gt; Mat4b;
<span class="lineNum">    2326 </span>            : 
<span class="lineNum">    2327 </span>            : typedef Mat_&lt;short&gt; Mat1s;
<span class="lineNum">    2328 </span>            : typedef Mat_&lt;Vec2s&gt; Mat2s;
<span class="lineNum">    2329 </span>            : typedef Mat_&lt;Vec3s&gt; Mat3s;
<span class="lineNum">    2330 </span>            : typedef Mat_&lt;Vec4s&gt; Mat4s;
<span class="lineNum">    2331 </span>            : 
<span class="lineNum">    2332 </span>            : typedef Mat_&lt;ushort&gt; Mat1w;
<span class="lineNum">    2333 </span>            : typedef Mat_&lt;Vec2w&gt; Mat2w;
<span class="lineNum">    2334 </span>            : typedef Mat_&lt;Vec3w&gt; Mat3w;
<span class="lineNum">    2335 </span>            : typedef Mat_&lt;Vec4w&gt; Mat4w;
<span class="lineNum">    2336 </span>            : 
<span class="lineNum">    2337 </span>            : typedef Mat_&lt;int&gt;   Mat1i;
<span class="lineNum">    2338 </span>            : typedef Mat_&lt;Vec2i&gt; Mat2i;
<span class="lineNum">    2339 </span>            : typedef Mat_&lt;Vec3i&gt; Mat3i;
<span class="lineNum">    2340 </span>            : typedef Mat_&lt;Vec4i&gt; Mat4i;
<span class="lineNum">    2341 </span>            : 
<span class="lineNum">    2342 </span>            : typedef Mat_&lt;float&gt; Mat1f;
<span class="lineNum">    2343 </span>            : typedef Mat_&lt;Vec2f&gt; Mat2f;
<span class="lineNum">    2344 </span>            : typedef Mat_&lt;Vec3f&gt; Mat3f;
<span class="lineNum">    2345 </span>            : typedef Mat_&lt;Vec4f&gt; Mat4f;
<span class="lineNum">    2346 </span>            : 
<span class="lineNum">    2347 </span>            : typedef Mat_&lt;double&gt; Mat1d;
<span class="lineNum">    2348 </span>            : typedef Mat_&lt;Vec2d&gt; Mat2d;
<span class="lineNum">    2349 </span>            : typedef Mat_&lt;Vec3d&gt; Mat3d;
<span class="lineNum">    2350 </span>            : typedef Mat_&lt;Vec4d&gt; Mat4d;
<span class="lineNum">    2351 </span>            : 
<span class="lineNum">    2352 </span>            : /** @todo document */
<span class="lineNum">    2353 </span>            : class CV_EXPORTS UMat
<span class="lineNum">    2354 </span>            : {
<span class="lineNum">    2355 </span>            : public:
<span class="lineNum">    2356 </span>            :     //! default constructor
<span class="lineNum">    2357 </span>            :     UMat(UMatUsageFlags usageFlags = USAGE_DEFAULT);
<span class="lineNum">    2358 </span>            :     //! constructs 2D matrix of the specified size and type
<span class="lineNum">    2359 </span>            :     // (_type is CV_8UC1, CV_64FC3, CV_32SC(12) etc.)
<span class="lineNum">    2360 </span>            :     UMat(int rows, int cols, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
<span class="lineNum">    2361 </span>            :     UMat(Size size, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
<span class="lineNum">    2362 </span>            :     //! constucts 2D matrix and fills it with the specified value _s.
<span class="lineNum">    2363 </span>            :     UMat(int rows, int cols, int type, const Scalar&amp; s, UMatUsageFlags usageFlags = USAGE_DEFAULT);
<span class="lineNum">    2364 </span>            :     UMat(Size size, int type, const Scalar&amp; s, UMatUsageFlags usageFlags = USAGE_DEFAULT);
<span class="lineNum">    2365 </span>            : 
<span class="lineNum">    2366 </span>            :     //! constructs n-dimensional matrix
<span class="lineNum">    2367 </span>            :     UMat(int ndims, const int* sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
<span class="lineNum">    2368 </span>            :     UMat(int ndims, const int* sizes, int type, const Scalar&amp; s, UMatUsageFlags usageFlags = USAGE_DEFAULT);
<span class="lineNum">    2369 </span>            : 
<span class="lineNum">    2370 </span>            :     //! copy constructor
<span class="lineNum">    2371 </span>            :     UMat(const UMat&amp; m);
<span class="lineNum">    2372 </span>            : 
<span class="lineNum">    2373 </span>            :     //! creates a matrix header for a part of the bigger matrix
<span class="lineNum">    2374 </span>            :     UMat(const UMat&amp; m, const Range&amp; rowRange, const Range&amp; colRange=Range::all());
<span class="lineNum">    2375 </span>            :     UMat(const UMat&amp; m, const Rect&amp; roi);
<span class="lineNum">    2376 </span>            :     UMat(const UMat&amp; m, const Range* ranges);
<span class="lineNum">    2377 </span>            :     UMat(const UMat&amp; m, const std::vector&lt;Range&gt;&amp; ranges);
<span class="lineNum">    2378 </span>            :     //! builds matrix from std::vector with or without copying the data
<span class="lineNum">    2379 </span>            :     template&lt;typename _Tp&gt; explicit UMat(const std::vector&lt;_Tp&gt;&amp; vec, bool copyData=false);
<span class="lineNum">    2380 </span>            : 
<span class="lineNum">    2381 </span>            :     //! builds matrix from cv::Vec; the data is copied by default
<span class="lineNum">    2382 </span>            :     template&lt;typename _Tp, int n&gt; explicit UMat(const Vec&lt;_Tp, n&gt;&amp; vec, bool copyData=true);
<span class="lineNum">    2383 </span>            :     //! builds matrix from cv::Matx; the data is copied by default
<span class="lineNum">    2384 </span>            :     template&lt;typename _Tp, int m, int n&gt; explicit UMat(const Matx&lt;_Tp, m, n&gt;&amp; mtx, bool copyData=true);
<span class="lineNum">    2385 </span>            :     //! builds matrix from a 2D point
<span class="lineNum">    2386 </span>            :     template&lt;typename _Tp&gt; explicit UMat(const Point_&lt;_Tp&gt;&amp; pt, bool copyData=true);
<span class="lineNum">    2387 </span>            :     //! builds matrix from a 3D point
<span class="lineNum">    2388 </span>            :     template&lt;typename _Tp&gt; explicit UMat(const Point3_&lt;_Tp&gt;&amp; pt, bool copyData=true);
<span class="lineNum">    2389 </span>            :     //! builds matrix from comma initializer
<span class="lineNum">    2390 </span>            :     template&lt;typename _Tp&gt; explicit UMat(const MatCommaInitializer_&lt;_Tp&gt;&amp; commaInitializer);
<span class="lineNum">    2391 </span>            : 
<span class="lineNum">    2392 </span>            :     //! destructor - calls release()
<span class="lineNum">    2393 </span>            :     ~UMat();
<span class="lineNum">    2394 </span>            :     //! assignment operators
<span class="lineNum">    2395 </span>            :     UMat&amp; operator = (const UMat&amp; m);
<span class="lineNum">    2396 </span>            : 
<span class="lineNum">    2397 </span>            :     Mat getMat(int flags) const;
<span class="lineNum">    2398 </span>            : 
<span class="lineNum">    2399 </span>            :     //! returns a new matrix header for the specified row
<span class="lineNum">    2400 </span>            :     UMat row(int y) const;
<span class="lineNum">    2401 </span>            :     //! returns a new matrix header for the specified column
<span class="lineNum">    2402 </span>            :     UMat col(int x) const;
<span class="lineNum">    2403 </span>            :     //! ... for the specified row span
<span class="lineNum">    2404 </span>            :     UMat rowRange(int startrow, int endrow) const;
<span class="lineNum">    2405 </span>            :     UMat rowRange(const Range&amp; r) const;
<span class="lineNum">    2406 </span>            :     //! ... for the specified column span
<span class="lineNum">    2407 </span>            :     UMat colRange(int startcol, int endcol) const;
<span class="lineNum">    2408 </span>            :     UMat colRange(const Range&amp; r) const;
<span class="lineNum">    2409 </span>            :     //! ... for the specified diagonal
<span class="lineNum">    2410 </span>            :     //! (d=0 - the main diagonal,
<span class="lineNum">    2411 </span>            :     //!  &gt;0 - a diagonal from the upper half,
<span class="lineNum">    2412 </span>            :     //!  &lt;0 - a diagonal from the lower half)
<span class="lineNum">    2413 </span>            :     UMat diag(int d=0) const;
<span class="lineNum">    2414 </span>            :     //! constructs a square diagonal matrix which main diagonal is vector &quot;d&quot;
<span class="lineNum">    2415 </span>            :     static UMat diag(const UMat&amp; d);
<span class="lineNum">    2416 </span>            : 
<span class="lineNum">    2417 </span>            :     //! returns deep copy of the matrix, i.e. the data is copied
<span class="lineNum">    2418 </span>            :     UMat clone() const;
<span class="lineNum">    2419 </span>            :     //! copies the matrix content to &quot;m&quot;.
<span class="lineNum">    2420 </span>            :     // It calls m.create(this-&gt;size(), this-&gt;type()).
<span class="lineNum">    2421 </span>            :     void copyTo( OutputArray m ) const;
<span class="lineNum">    2422 </span>            :     //! copies those matrix elements to &quot;m&quot; that are marked with non-zero mask elements.
<span class="lineNum">    2423 </span>            :     void copyTo( OutputArray m, InputArray mask ) const;
<span class="lineNum">    2424 </span>            :     //! converts matrix to another datatype with optional scaling. See cvConvertScale.
<span class="lineNum">    2425 </span>            :     void convertTo( OutputArray m, int rtype, double alpha=1, double beta=0 ) const;
<span class="lineNum">    2426 </span>            : 
<span class="lineNum">    2427 </span>            :     void assignTo( UMat&amp; m, int type=-1 ) const;
<span class="lineNum">    2428 </span>            : 
<span class="lineNum">    2429 </span>            :     //! sets every matrix element to s
<span class="lineNum">    2430 </span>            :     UMat&amp; operator = (const Scalar&amp; s);
<span class="lineNum">    2431 </span>            :     //! sets some of the matrix elements to s, according to the mask
<span class="lineNum">    2432 </span>            :     UMat&amp; setTo(InputArray value, InputArray mask=noArray());
<span class="lineNum">    2433 </span>            :     //! creates alternative matrix header for the same data, with different
<span class="lineNum">    2434 </span>            :     // number of channels and/or different number of rows. see cvReshape.
<span class="lineNum">    2435 </span>            :     UMat reshape(int cn, int rows=0) const;
<span class="lineNum">    2436 </span>            :     UMat reshape(int cn, int newndims, const int* newsz) const;
<span class="lineNum">    2437 </span>            : 
<span class="lineNum">    2438 </span>            :     //! matrix transposition by means of matrix expressions
<span class="lineNum">    2439 </span>            :     UMat t() const;
<span class="lineNum">    2440 </span>            :     //! matrix inversion by means of matrix expressions
<span class="lineNum">    2441 </span>            :     UMat inv(int method=DECOMP_LU) const;
<span class="lineNum">    2442 </span>            :     //! per-element matrix multiplication by means of matrix expressions
<span class="lineNum">    2443 </span>            :     UMat mul(InputArray m, double scale=1) const;
<span class="lineNum">    2444 </span>            : 
<span class="lineNum">    2445 </span>            :     //! computes dot-product
<span class="lineNum">    2446 </span>            :     double dot(InputArray m) const;
<span class="lineNum">    2447 </span>            : 
<span class="lineNum">    2448 </span>            :     //! Matlab-style matrix initialization
<span class="lineNum">    2449 </span>            :     static UMat zeros(int rows, int cols, int type);
<span class="lineNum">    2450 </span>            :     static UMat zeros(Size size, int type);
<span class="lineNum">    2451 </span>            :     static UMat zeros(int ndims, const int* sz, int type);
<span class="lineNum">    2452 </span>            :     static UMat ones(int rows, int cols, int type);
<span class="lineNum">    2453 </span>            :     static UMat ones(Size size, int type);
<span class="lineNum">    2454 </span>            :     static UMat ones(int ndims, const int* sz, int type);
<span class="lineNum">    2455 </span>            :     static UMat eye(int rows, int cols, int type);
<span class="lineNum">    2456 </span>            :     static UMat eye(Size size, int type);
<span class="lineNum">    2457 </span>            : 
<span class="lineNum">    2458 </span>            :     //! allocates new matrix data unless the matrix already has specified size and type.
<span class="lineNum">    2459 </span>            :     // previous data is unreferenced if needed.
<span class="lineNum">    2460 </span>            :     void create(int rows, int cols, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
<span class="lineNum">    2461 </span>            :     void create(Size size, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
<span class="lineNum">    2462 </span>            :     void create(int ndims, const int* sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
<span class="lineNum">    2463 </span>            :     void create(const std::vector&lt;int&gt;&amp; sizes, int type, UMatUsageFlags usageFlags = USAGE_DEFAULT);
<span class="lineNum">    2464 </span>            : 
<span class="lineNum">    2465 </span>            :     //! increases the reference counter; use with care to avoid memleaks
<span class="lineNum">    2466 </span>            :     void addref();
<span class="lineNum">    2467 </span>            :     //! decreases reference counter;
<span class="lineNum">    2468 </span>            :     // deallocates the data when reference counter reaches 0.
<span class="lineNum">    2469 </span>            :     void release();
<span class="lineNum">    2470 </span>            : 
<span class="lineNum">    2471 </span>            :     //! deallocates the matrix data
<span class="lineNum">    2472 </span>            :     void deallocate();
<span class="lineNum">    2473 </span>            :     //! internal use function; properly re-allocates _size, _step arrays
<span class="lineNum">    2474 </span>            :     void copySize(const UMat&amp; m);
<span class="lineNum">    2475 </span>            : 
<span class="lineNum">    2476 </span>            :     //! locates matrix header within a parent matrix. See below
<span class="lineNum">    2477 </span>            :     void locateROI( Size&amp; wholeSize, Point&amp; ofs ) const;
<span class="lineNum">    2478 </span>            :     //! moves/resizes the current matrix ROI inside the parent matrix.
<span class="lineNum">    2479 </span>            :     UMat&amp; adjustROI( int dtop, int dbottom, int dleft, int dright );
<span class="lineNum">    2480 </span>            :     //! extracts a rectangular sub-matrix
<span class="lineNum">    2481 </span>            :     // (this is a generalized form of row, rowRange etc.)
<span class="lineNum">    2482 </span>            :     UMat operator()( Range rowRange, Range colRange ) const;
<span class="lineNum">    2483 </span>            :     UMat operator()( const Rect&amp; roi ) const;
<span class="lineNum">    2484 </span>            :     UMat operator()( const Range* ranges ) const;
<span class="lineNum">    2485 </span>            :     UMat operator()(const std::vector&lt;Range&gt;&amp; ranges) const;
<span class="lineNum">    2486 </span>            : 
<span class="lineNum">    2487 </span>            :     //! returns true iff the matrix data is continuous
<span class="lineNum">    2488 </span>            :     // (i.e. when there are no gaps between successive rows).
<span class="lineNum">    2489 </span>            :     // similar to CV_IS_MAT_CONT(cvmat-&gt;type)
<span class="lineNum">    2490 </span>            :     bool isContinuous() const;
<span class="lineNum">    2491 </span>            : 
<span class="lineNum">    2492 </span>            :     //! returns true if the matrix is a submatrix of another matrix
<span class="lineNum">    2493 </span>            :     bool isSubmatrix() const;
<span class="lineNum">    2494 </span>            : 
<span class="lineNum">    2495 </span>            :     //! returns element size in bytes,
<span class="lineNum">    2496 </span>            :     // similar to CV_ELEM_SIZE(cvmat-&gt;type)
<span class="lineNum">    2497 </span>            :     size_t elemSize() const;
<span class="lineNum">    2498 </span>            :     //! returns the size of element channel in bytes.
<span class="lineNum">    2499 </span>            :     size_t elemSize1() const;
<span class="lineNum">    2500 </span>            :     //! returns element type, similar to CV_MAT_TYPE(cvmat-&gt;type)
<span class="lineNum">    2501 </span>            :     int type() const;
<span class="lineNum">    2502 </span>            :     //! returns element type, similar to CV_MAT_DEPTH(cvmat-&gt;type)
<span class="lineNum">    2503 </span>            :     int depth() const;
<span class="lineNum">    2504 </span>            :     //! returns element type, similar to CV_MAT_CN(cvmat-&gt;type)
<span class="lineNum">    2505 </span>            :     int channels() const;
<span class="lineNum">    2506 </span>            :     //! returns step/elemSize1()
<span class="lineNum">    2507 </span>            :     size_t step1(int i=0) const;
<span class="lineNum">    2508 </span>            :     //! returns true if matrix data is NULL
<span class="lineNum">    2509 </span>            :     bool empty() const;
<span class="lineNum">    2510 </span>            :     //! returns the total number of matrix elements
<span class="lineNum">    2511 </span>            :     size_t total() const;
<span class="lineNum">    2512 </span>            : 
<span class="lineNum">    2513 </span>            :     //! returns N if the matrix is 1-channel (N x ptdim) or ptdim-channel (1 x N) or (N x 1); negative number otherwise
<span class="lineNum">    2514 </span>            :     int checkVector(int elemChannels, int depth=-1, bool requireContinuous=true) const;
<span class="lineNum">    2515 </span>            : 
<span class="lineNum">    2516 </span>            : #ifdef CV_CXX_MOVE_SEMANTICS
<span class="lineNum">    2517 </span>            :     UMat(UMat&amp;&amp; m);
<span class="lineNum">    2518 </span>            :     UMat&amp; operator = (UMat&amp;&amp; m);
<span class="lineNum">    2519 </span>            : #endif
<span class="lineNum">    2520 </span>            : 
<span class="lineNum">    2521 </span>            :     /*! Returns the OpenCL buffer handle on which UMat operates on.
<span class="lineNum">    2522 </span>            :         The UMat instance should be kept alive during the use of the handle to prevent the buffer to be
<span class="lineNum">    2523 </span>            :         returned to the OpenCV buffer pool.
<span class="lineNum">    2524 </span>            :      */
<span class="lineNum">    2525 </span>            :     void* handle(int accessFlags) const;
<span class="lineNum">    2526 </span>            :     void ndoffset(size_t* ofs) const;
<span class="lineNum">    2527 </span>            : 
<span class="lineNum">    2528 </span>            :     enum { MAGIC_VAL  = 0x42FF0000, AUTO_STEP = 0, CONTINUOUS_FLAG = CV_MAT_CONT_FLAG, SUBMATRIX_FLAG = CV_SUBMAT_FLAG };
<span class="lineNum">    2529 </span>            :     enum { MAGIC_MASK = 0xFFFF0000, TYPE_MASK = 0x00000FFF, DEPTH_MASK = 7 };
<span class="lineNum">    2530 </span>            : 
<span class="lineNum">    2531 </span>            :     /*! includes several bit-fields:
<span class="lineNum">    2532 </span>            :          - the magic signature
<span class="lineNum">    2533 </span>            :          - continuity flag
<span class="lineNum">    2534 </span>            :          - depth
<span class="lineNum">    2535 </span>            :          - number of channels
<span class="lineNum">    2536 </span>            :      */
<span class="lineNum">    2537 </span>            :     int flags;
<span class="lineNum">    2538 </span>            :     //! the matrix dimensionality, &gt;= 2
<span class="lineNum">    2539 </span>            :     int dims;
<span class="lineNum">    2540 </span>            :     //! the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions
<span class="lineNum">    2541 </span>            :     int rows, cols;
<span class="lineNum">    2542 </span>            : 
<span class="lineNum">    2543 </span>            :     //! custom allocator
<span class="lineNum">    2544 </span>            :     MatAllocator* allocator;
<span class="lineNum">    2545 </span>            :     UMatUsageFlags usageFlags; // usage flags for allocator
<span class="lineNum">    2546 </span>            :     //! and the standard allocator
<span class="lineNum">    2547 </span>            :     static MatAllocator* getStdAllocator();
<span class="lineNum">    2548 </span>            : 
<span class="lineNum">    2549 </span>            :     // black-box container of UMat data
<span class="lineNum">    2550 </span>            :     UMatData* u;
<span class="lineNum">    2551 </span>            : 
<span class="lineNum">    2552 </span>            :     // offset of the submatrix (or 0)
<span class="lineNum">    2553 </span>            :     size_t offset;
<span class="lineNum">    2554 </span>            : 
<span class="lineNum">    2555 </span>            :     MatSize size;
<span class="lineNum">    2556 </span>            :     MatStep step;
<span class="lineNum">    2557 </span>            : 
<span class="lineNum">    2558 </span>            : protected:
<span class="lineNum">    2559 </span>            : };
<span class="lineNum">    2560 </span>            : 
<span class="lineNum">    2561 </span>            : 
<span class="lineNum">    2562 </span>            : /////////////////////////// multi-dimensional sparse matrix //////////////////////////
<span class="lineNum">    2563 </span>            : 
<span class="lineNum">    2564 </span>            : /** @brief The class SparseMat represents multi-dimensional sparse numerical arrays.
<span class="lineNum">    2565 </span>            : 
<span class="lineNum">    2566 </span>            : Such a sparse array can store elements of any type that Mat can store. *Sparse* means that only
<span class="lineNum">    2567 </span>            : non-zero elements are stored (though, as a result of operations on a sparse matrix, some of its
<span class="lineNum">    2568 </span>            : stored elements can actually become 0. It is up to you to detect such elements and delete them
<span class="lineNum">    2569 </span>            : using SparseMat::erase ). The non-zero elements are stored in a hash table that grows when it is
<span class="lineNum">    2570 </span>            : filled so that the search time is O(1) in average (regardless of whether element is there or not).
<span class="lineNum">    2571 </span>            : Elements can be accessed using the following methods:
<span class="lineNum">    2572 </span>            : -   Query operations (SparseMat::ptr and the higher-level SparseMat::ref, SparseMat::value and
<span class="lineNum">    2573 </span>            :     SparseMat::find), for example:
<span class="lineNum">    2574 </span>            :     @code
<span class="lineNum">    2575 </span>            :         const int dims = 5;
<span class="lineNum">    2576 </span>            :         int size[5] = {10, 10, 10, 10, 10};
<span class="lineNum">    2577 </span>            :         SparseMat sparse_mat(dims, size, CV_32F);
<span class="lineNum">    2578 </span>            :         for(int i = 0; i &lt; 1000; i++)
<span class="lineNum">    2579 </span>            :         {
<span class="lineNum">    2580 </span>            :             int idx[dims];
<span class="lineNum">    2581 </span>            :             for(int k = 0; k &lt; dims; k++)
<span class="lineNum">    2582 </span>            :                 idx[k] = rand() % size[k];
<span class="lineNum">    2583 </span>            :             sparse_mat.ref&lt;float&gt;(idx) += 1.f;
<span class="lineNum">    2584 </span>            :         }
<span class="lineNum">    2585 </span>            :         cout &lt;&lt; &quot;nnz = &quot; &lt;&lt; sparse_mat.nzcount() &lt;&lt; endl;
<span class="lineNum">    2586 </span>            :     @endcode
<span class="lineNum">    2587 </span>            : -   Sparse matrix iterators. They are similar to MatIterator but different from NAryMatIterator.
<span class="lineNum">    2588 </span>            :     That is, the iteration loop is familiar to STL users:
<span class="lineNum">    2589 </span>            :     @code
<span class="lineNum">    2590 </span>            :         // prints elements of a sparse floating-point matrix
<span class="lineNum">    2591 </span>            :         // and the sum of elements.
<span class="lineNum">    2592 </span>            :         SparseMatConstIterator_&lt;float&gt;
<span class="lineNum">    2593 </span>            :             it = sparse_mat.begin&lt;float&gt;(),
<span class="lineNum">    2594 </span>            :             it_end = sparse_mat.end&lt;float&gt;();
<span class="lineNum">    2595 </span>            :         double s = 0;
<span class="lineNum">    2596 </span>            :         int dims = sparse_mat.dims();
<span class="lineNum">    2597 </span>            :         for(; it != it_end; ++it)
<span class="lineNum">    2598 </span>            :         {
<span class="lineNum">    2599 </span>            :             // print element indices and the element value
<span class="lineNum">    2600 </span>            :             const SparseMat::Node* n = it.node();
<span class="lineNum">    2601 </span>            :             printf(&quot;(&quot;);
<span class="lineNum">    2602 </span>            :             for(int i = 0; i &lt; dims; i++)
<span class="lineNum">    2603 </span>            :                 printf(&quot;%d%s&quot;, n-&gt;idx[i], i &lt; dims-1 ? &quot;, &quot; : &quot;)&quot;);
<span class="lineNum">    2604 </span>            :             printf(&quot;: %g\n&quot;, it.value&lt;float&gt;());
<span class="lineNum">    2605 </span>            :             s += *it;
<span class="lineNum">    2606 </span>            :         }
<span class="lineNum">    2607 </span>            :         printf(&quot;Element sum is %g\n&quot;, s);
<span class="lineNum">    2608 </span>            :     @endcode
<span class="lineNum">    2609 </span>            :     If you run this loop, you will notice that elements are not enumerated in a logical order
<span class="lineNum">    2610 </span>            :     (lexicographical, and so on). They come in the same order as they are stored in the hash table
<span class="lineNum">    2611 </span>            :     (semi-randomly). You may collect pointers to the nodes and sort them to get the proper ordering.
<span class="lineNum">    2612 </span>            :     Note, however, that pointers to the nodes may become invalid when you add more elements to the
<span class="lineNum">    2613 </span>            :     matrix. This may happen due to possible buffer reallocation.
<span class="lineNum">    2614 </span>            : -   Combination of the above 2 methods when you need to process 2 or more sparse matrices
<span class="lineNum">    2615 </span>            :     simultaneously. For example, this is how you can compute unnormalized cross-correlation of the 2
<span class="lineNum">    2616 </span>            :     floating-point sparse matrices:
<span class="lineNum">    2617 </span>            :     @code
<span class="lineNum">    2618 </span>            :         double cross_corr(const SparseMat&amp; a, const SparseMat&amp; b)
<span class="lineNum">    2619 </span>            :         {
<span class="lineNum">    2620 </span>            :             const SparseMat *_a = &amp;a, *_b = &amp;b;
<span class="lineNum">    2621 </span>            :             // if b contains less elements than a,
<span class="lineNum">    2622 </span>            :             // it is faster to iterate through b
<span class="lineNum">    2623 </span>            :             if(_a-&gt;nzcount() &gt; _b-&gt;nzcount())
<span class="lineNum">    2624 </span>            :                 std::swap(_a, _b);
<span class="lineNum">    2625 </span>            :             SparseMatConstIterator_&lt;float&gt; it = _a-&gt;begin&lt;float&gt;(),
<span class="lineNum">    2626 </span>            :                                            it_end = _a-&gt;end&lt;float&gt;();
<span class="lineNum">    2627 </span>            :             double ccorr = 0;
<span class="lineNum">    2628 </span>            :             for(; it != it_end; ++it)
<span class="lineNum">    2629 </span>            :             {
<span class="lineNum">    2630 </span>            :                 // take the next element from the first matrix
<span class="lineNum">    2631 </span>            :                 float avalue = *it;
<span class="lineNum">    2632 </span>            :                 const Node* anode = it.node();
<span class="lineNum">    2633 </span>            :                 // and try to find an element with the same index in the second matrix.
<span class="lineNum">    2634 </span>            :                 // since the hash value depends only on the element index,
<span class="lineNum">    2635 </span>            :                 // reuse the hash value stored in the node
<span class="lineNum">    2636 </span>            :                 float bvalue = _b-&gt;value&lt;float&gt;(anode-&gt;idx,&amp;anode-&gt;hashval);
<span class="lineNum">    2637 </span>            :                 ccorr += avalue*bvalue;
<span class="lineNum">    2638 </span>            :             }
<span class="lineNum">    2639 </span>            :             return ccorr;
<span class="lineNum">    2640 </span>            :         }
<span class="lineNum">    2641 </span>            :     @endcode
<span class="lineNum">    2642 </span>            :  */
<span class="lineNum">    2643 </span>            : class CV_EXPORTS SparseMat
<span class="lineNum">    2644 </span>            : {
<span class="lineNum">    2645 </span>            : public:
<span class="lineNum">    2646 </span>            :     typedef SparseMatIterator iterator;
<span class="lineNum">    2647 </span>            :     typedef SparseMatConstIterator const_iterator;
<span class="lineNum">    2648 </span>            : 
<span class="lineNum">    2649 </span>            :     enum { MAGIC_VAL=0x42FD0000, MAX_DIM=32, HASH_SCALE=0x5bd1e995, HASH_BIT=0x80000000 };
<span class="lineNum">    2650 </span>            : 
<span class="lineNum">    2651 </span>            :     //! the sparse matrix header
<span class="lineNum">    2652 </span>            :     struct CV_EXPORTS Hdr
<span class="lineNum">    2653 </span>            :     {
<span class="lineNum">    2654 </span>            :         Hdr(int _dims, const int* _sizes, int _type);
<span class="lineNum">    2655 </span>            :         void clear();
<span class="lineNum">    2656 </span>            :         int refcount;
<span class="lineNum">    2657 </span>            :         int dims;
<span class="lineNum">    2658 </span>            :         int valueOffset;
<span class="lineNum">    2659 </span>            :         size_t nodeSize;
<span class="lineNum">    2660 </span>            :         size_t nodeCount;
<span class="lineNum">    2661 </span>            :         size_t freeList;
<span class="lineNum">    2662 </span>            :         std::vector&lt;uchar&gt; pool;
<span class="lineNum">    2663 </span>            :         std::vector&lt;size_t&gt; hashtab;
<span class="lineNum">    2664 </span>            :         int size[MAX_DIM];
<span class="lineNum">    2665 </span>            :     };
<span class="lineNum">    2666 </span>            : 
<span class="lineNum">    2667 </span>            :     //! sparse matrix node - element of a hash table
<span class="lineNum">    2668 </span>            :     struct CV_EXPORTS Node
<span class="lineNum">    2669 </span>            :     {
<span class="lineNum">    2670 </span>            :         //! hash value
<span class="lineNum">    2671 </span>            :         size_t hashval;
<span class="lineNum">    2672 </span>            :         //! index of the next node in the same hash table entry
<span class="lineNum">    2673 </span>            :         size_t next;
<span class="lineNum">    2674 </span>            :         //! index of the matrix element
<span class="lineNum">    2675 </span>            :         int idx[MAX_DIM];
<span class="lineNum">    2676 </span>            :     };
<span class="lineNum">    2677 </span>            : 
<span class="lineNum">    2678 </span>            :     /** @brief Various SparseMat constructors.
<span class="lineNum">    2679 </span>            :      */
<span class="lineNum">    2680 </span>            :     SparseMat();
<span class="lineNum">    2681 </span>            : 
<span class="lineNum">    2682 </span>            :     /** @overload
<span class="lineNum">    2683 </span>            :     @param dims Array dimensionality.
<span class="lineNum">    2684 </span>            :     @param _sizes Sparce matrix size on all dementions.
<span class="lineNum">    2685 </span>            :     @param _type Sparse matrix data type.
<span class="lineNum">    2686 </span>            :     */
<span class="lineNum">    2687 </span>            :     SparseMat(int dims, const int* _sizes, int _type);
<span class="lineNum">    2688 </span>            : 
<span class="lineNum">    2689 </span>            :     /** @overload
<span class="lineNum">    2690 </span>            :     @param m Source matrix for copy constructor. If m is dense matrix (ocvMat) then it will be converted
<span class="lineNum">    2691 </span>            :     to sparse representation.
<span class="lineNum">    2692 </span>            :     */
<span class="lineNum">    2693 </span>            :     SparseMat(const SparseMat&amp; m);
<span class="lineNum">    2694 </span>            : 
<span class="lineNum">    2695 </span>            :     /** @overload
<span class="lineNum">    2696 </span>            :     @param m Source matrix for copy constructor. If m is dense matrix (ocvMat) then it will be converted
<span class="lineNum">    2697 </span>            :     to sparse representation.
<span class="lineNum">    2698 </span>            :     */
<span class="lineNum">    2699 </span>            :     explicit SparseMat(const Mat&amp; m);
<span class="lineNum">    2700 </span>            : 
<span class="lineNum">    2701 </span>            :     //! the destructor
<span class="lineNum">    2702 </span>            :     ~SparseMat();
<span class="lineNum">    2703 </span>            : 
<span class="lineNum">    2704 </span>            :     //! assignment operator. This is O(1) operation, i.e. no data is copied
<span class="lineNum">    2705 </span>            :     SparseMat&amp; operator = (const SparseMat&amp; m);
<span class="lineNum">    2706 </span>            :     //! equivalent to the corresponding constructor
<span class="lineNum">    2707 </span>            :     SparseMat&amp; operator = (const Mat&amp; m);
<span class="lineNum">    2708 </span>            : 
<span class="lineNum">    2709 </span>            :     //! creates full copy of the matrix
<span class="lineNum">    2710 </span>            :     SparseMat clone() const;
<span class="lineNum">    2711 </span>            : 
<span class="lineNum">    2712 </span>            :     //! copies all the data to the destination matrix. All the previous content of m is erased
<span class="lineNum">    2713 </span>            :     void copyTo( SparseMat&amp; m ) const;
<span class="lineNum">    2714 </span>            :     //! converts sparse matrix to dense matrix.
<span class="lineNum">    2715 </span>            :     void copyTo( Mat&amp; m ) const;
<span class="lineNum">    2716 </span>            :     //! multiplies all the matrix elements by the specified scale factor alpha and converts the results to the specified data type
<span class="lineNum">    2717 </span>            :     void convertTo( SparseMat&amp; m, int rtype, double alpha=1 ) const;
<span class="lineNum">    2718 </span>            :     //! converts sparse matrix to dense n-dim matrix with optional type conversion and scaling.
<span class="lineNum">    2719 </span>            :     /*!
<span class="lineNum">    2720 </span>            :         @param [out] m - output matrix; if it does not have a proper size or type before the operation,
<span class="lineNum">    2721 </span>            :             it is reallocated
<span class="lineNum">    2722 </span>            :         @param [in] rtype - desired output matrix type or, rather, the depth since the number of channels
<span class="lineNum">    2723 </span>            :             are the same as the input has; if rtype is negative, the output matrix will have the
<span class="lineNum">    2724 </span>            :             same type as the input.
<span class="lineNum">    2725 </span>            :         @param [in] alpha - optional scale factor
<span class="lineNum">    2726 </span>            :         @param [in] beta - optional delta added to the scaled values
<span class="lineNum">    2727 </span>            :     */
<span class="lineNum">    2728 </span>            :     void convertTo( Mat&amp; m, int rtype, double alpha=1, double beta=0 ) const;
<span class="lineNum">    2729 </span>            : 
<span class="lineNum">    2730 </span>            :     // not used now
<span class="lineNum">    2731 </span>            :     void assignTo( SparseMat&amp; m, int type=-1 ) const;
<span class="lineNum">    2732 </span>            : 
<span class="lineNum">    2733 </span>            :     //! reallocates sparse matrix.
<span class="lineNum">    2734 </span>            :     /*!
<span class="lineNum">    2735 </span>            :         If the matrix already had the proper size and type,
<span class="lineNum">    2736 </span>            :         it is simply cleared with clear(), otherwise,
<span class="lineNum">    2737 </span>            :         the old matrix is released (using release()) and the new one is allocated.
<span class="lineNum">    2738 </span>            :     */
<span class="lineNum">    2739 </span>            :     void create(int dims, const int* _sizes, int _type);
<span class="lineNum">    2740 </span>            :     //! sets all the sparse matrix elements to 0, which means clearing the hash table.
<span class="lineNum">    2741 </span>            :     void clear();
<span class="lineNum">    2742 </span>            :     //! manually increments the reference counter to the header.
<span class="lineNum">    2743 </span>            :     void addref();
<span class="lineNum">    2744 </span>            :     // decrements the header reference counter. When the counter reaches 0, the header and all the underlying data are deallocated.
<span class="lineNum">    2745 </span>            :     void release();
<span class="lineNum">    2746 </span>            : 
<span class="lineNum">    2747 </span>            :     //! converts sparse matrix to the old-style representation; all the elements are copied.
<span class="lineNum">    2748 </span>            :     //operator CvSparseMat*() const;
<span class="lineNum">    2749 </span>            :     //! returns the size of each element in bytes (not including the overhead - the space occupied by SparseMat::Node elements)
<span class="lineNum">    2750 </span>            :     size_t elemSize() const;
<span class="lineNum">    2751 </span>            :     //! returns elemSize()/channels()
<span class="lineNum">    2752 </span>            :     size_t elemSize1() const;
<span class="lineNum">    2753 </span>            : 
<span class="lineNum">    2754 </span>            :     //! returns type of sparse matrix elements
<span class="lineNum">    2755 </span>            :     int type() const;
<span class="lineNum">    2756 </span>            :     //! returns the depth of sparse matrix elements
<span class="lineNum">    2757 </span>            :     int depth() const;
<span class="lineNum">    2758 </span>            :     //! returns the number of channels
<span class="lineNum">    2759 </span>            :     int channels() const;
<span class="lineNum">    2760 </span>            : 
<span class="lineNum">    2761 </span>            :     //! returns the array of sizes, or NULL if the matrix is not allocated
<span class="lineNum">    2762 </span>            :     const int* size() const;
<span class="lineNum">    2763 </span>            :     //! returns the size of i-th matrix dimension (or 0)
<span class="lineNum">    2764 </span>            :     int size(int i) const;
<span class="lineNum">    2765 </span>            :     //! returns the matrix dimensionality
<span class="lineNum">    2766 </span>            :     int dims() const;
<span class="lineNum">    2767 </span>            :     //! returns the number of non-zero elements (=the number of hash table nodes)
<span class="lineNum">    2768 </span>            :     size_t nzcount() const;
<span class="lineNum">    2769 </span>            : 
<span class="lineNum">    2770 </span>            :     //! computes the element hash value (1D case)
<span class="lineNum">    2771 </span>            :     size_t hash(int i0) const;
<span class="lineNum">    2772 </span>            :     //! computes the element hash value (2D case)
<span class="lineNum">    2773 </span>            :     size_t hash(int i0, int i1) const;
<span class="lineNum">    2774 </span>            :     //! computes the element hash value (3D case)
<span class="lineNum">    2775 </span>            :     size_t hash(int i0, int i1, int i2) const;
<span class="lineNum">    2776 </span>            :     //! computes the element hash value (nD case)
<span class="lineNum">    2777 </span>            :     size_t hash(const int* idx) const;
<span class="lineNum">    2778 </span>            : 
<span class="lineNum">    2779 </span>            :     //!@{
<span class="lineNum">    2780 </span>            :     /*!
<span class="lineNum">    2781 </span>            :      specialized variants for 1D, 2D, 3D cases and the generic_type one for n-D case.
<span class="lineNum">    2782 </span>            :      return pointer to the matrix element.
<span class="lineNum">    2783 </span>            :       - if the element is there (it's non-zero), the pointer to it is returned
<span class="lineNum">    2784 </span>            :       - if it's not there and createMissing=false, NULL pointer is returned
<span class="lineNum">    2785 </span>            :       - if it's not there and createMissing=true, then the new element
<span class="lineNum">    2786 </span>            :         is created and initialized with 0. Pointer to it is returned
<span class="lineNum">    2787 </span>            :       - if the optional hashval pointer is not NULL, the element hash value is
<span class="lineNum">    2788 </span>            :         not computed, but *hashval is taken instead.
<span class="lineNum">    2789 </span>            :     */
<span class="lineNum">    2790 </span>            :     //! returns pointer to the specified element (1D case)
<span class="lineNum">    2791 </span>            :     uchar* ptr(int i0, bool createMissing, size_t* hashval=0);
<span class="lineNum">    2792 </span>            :     //! returns pointer to the specified element (2D case)
<span class="lineNum">    2793 </span>            :     uchar* ptr(int i0, int i1, bool createMissing, size_t* hashval=0);
<span class="lineNum">    2794 </span>            :     //! returns pointer to the specified element (3D case)
<span class="lineNum">    2795 </span>            :     uchar* ptr(int i0, int i1, int i2, bool createMissing, size_t* hashval=0);
<span class="lineNum">    2796 </span>            :     //! returns pointer to the specified element (nD case)
<span class="lineNum">    2797 </span>            :     uchar* ptr(const int* idx, bool createMissing, size_t* hashval=0);
<span class="lineNum">    2798 </span>            :     //!@}
<span class="lineNum">    2799 </span>            : 
<span class="lineNum">    2800 </span>            :     //!@{
<span class="lineNum">    2801 </span>            :     /*!
<span class="lineNum">    2802 </span>            :      return read-write reference to the specified sparse matrix element.
<span class="lineNum">    2803 </span>            : 
<span class="lineNum">    2804 </span>            :      `ref&lt;_Tp&gt;(i0,...[,hashval])` is equivalent to `*(_Tp*)ptr(i0,...,true[,hashval])`.
<span class="lineNum">    2805 </span>            :      The methods always return a valid reference.
<span class="lineNum">    2806 </span>            :      If the element did not exist, it is created and initialiazed with 0.
<span class="lineNum">    2807 </span>            :     */
<span class="lineNum">    2808 </span>            :     //! returns reference to the specified element (1D case)
<span class="lineNum">    2809 </span>            :     template&lt;typename _Tp&gt; _Tp&amp; ref(int i0, size_t* hashval=0);
<span class="lineNum">    2810 </span>            :     //! returns reference to the specified element (2D case)
<span class="lineNum">    2811 </span>            :     template&lt;typename _Tp&gt; _Tp&amp; ref(int i0, int i1, size_t* hashval=0);
<span class="lineNum">    2812 </span>            :     //! returns reference to the specified element (3D case)
<span class="lineNum">    2813 </span>            :     template&lt;typename _Tp&gt; _Tp&amp; ref(int i0, int i1, int i2, size_t* hashval=0);
<span class="lineNum">    2814 </span>            :     //! returns reference to the specified element (nD case)
<span class="lineNum">    2815 </span>            :     template&lt;typename _Tp&gt; _Tp&amp; ref(const int* idx, size_t* hashval=0);
<span class="lineNum">    2816 </span>            :     //!@}
<span class="lineNum">    2817 </span>            : 
<span class="lineNum">    2818 </span>            :     //!@{
<span class="lineNum">    2819 </span>            :     /*!
<span class="lineNum">    2820 </span>            :      return value of the specified sparse matrix element.
<span class="lineNum">    2821 </span>            : 
<span class="lineNum">    2822 </span>            :      `value&lt;_Tp&gt;(i0,...[,hashval])` is equivalent to
<span class="lineNum">    2823 </span>            :      @code
<span class="lineNum">    2824 </span>            :      { const _Tp* p = find&lt;_Tp&gt;(i0,...[,hashval]); return p ? *p : _Tp(); }
<span class="lineNum">    2825 </span>            :      @endcode
<span class="lineNum">    2826 </span>            : 
<span class="lineNum">    2827 </span>            :      That is, if the element did not exist, the methods return 0.
<span class="lineNum">    2828 </span>            :      */
<span class="lineNum">    2829 </span>            :     //! returns value of the specified element (1D case)
<span class="lineNum">    2830 </span>            :     template&lt;typename _Tp&gt; _Tp value(int i0, size_t* hashval=0) const;
<span class="lineNum">    2831 </span>            :     //! returns value of the specified element (2D case)
<span class="lineNum">    2832 </span>            :     template&lt;typename _Tp&gt; _Tp value(int i0, int i1, size_t* hashval=0) const;
<span class="lineNum">    2833 </span>            :     //! returns value of the specified element (3D case)
<span class="lineNum">    2834 </span>            :     template&lt;typename _Tp&gt; _Tp value(int i0, int i1, int i2, size_t* hashval=0) const;
<span class="lineNum">    2835 </span>            :     //! returns value of the specified element (nD case)
<span class="lineNum">    2836 </span>            :     template&lt;typename _Tp&gt; _Tp value(const int* idx, size_t* hashval=0) const;
<span class="lineNum">    2837 </span>            :     //!@}
<span class="lineNum">    2838 </span>            : 
<span class="lineNum">    2839 </span>            :     //!@{
<span class="lineNum">    2840 </span>            :     /*!
<span class="lineNum">    2841 </span>            :      Return pointer to the specified sparse matrix element if it exists
<span class="lineNum">    2842 </span>            : 
<span class="lineNum">    2843 </span>            :      `find&lt;_Tp&gt;(i0,...[,hashval])` is equivalent to `(_const Tp*)ptr(i0,...false[,hashval])`.
<span class="lineNum">    2844 </span>            : 
<span class="lineNum">    2845 </span>            :      If the specified element does not exist, the methods return NULL.
<span class="lineNum">    2846 </span>            :     */
<span class="lineNum">    2847 </span>            :     //! returns pointer to the specified element (1D case)
<span class="lineNum">    2848 </span>            :     template&lt;typename _Tp&gt; const _Tp* find(int i0, size_t* hashval=0) const;
<span class="lineNum">    2849 </span>            :     //! returns pointer to the specified element (2D case)
<span class="lineNum">    2850 </span>            :     template&lt;typename _Tp&gt; const _Tp* find(int i0, int i1, size_t* hashval=0) const;
<span class="lineNum">    2851 </span>            :     //! returns pointer to the specified element (3D case)
<span class="lineNum">    2852 </span>            :     template&lt;typename _Tp&gt; const _Tp* find(int i0, int i1, int i2, size_t* hashval=0) const;
<span class="lineNum">    2853 </span>            :     //! returns pointer to the specified element (nD case)
<span class="lineNum">    2854 </span>            :     template&lt;typename _Tp&gt; const _Tp* find(const int* idx, size_t* hashval=0) const;
<span class="lineNum">    2855 </span>            :     //!@}
<span class="lineNum">    2856 </span>            : 
<span class="lineNum">    2857 </span>            :     //! erases the specified element (2D case)
<span class="lineNum">    2858 </span>            :     void erase(int i0, int i1, size_t* hashval=0);
<span class="lineNum">    2859 </span>            :     //! erases the specified element (3D case)
<span class="lineNum">    2860 </span>            :     void erase(int i0, int i1, int i2, size_t* hashval=0);
<span class="lineNum">    2861 </span>            :     //! erases the specified element (nD case)
<span class="lineNum">    2862 </span>            :     void erase(const int* idx, size_t* hashval=0);
<span class="lineNum">    2863 </span>            : 
<span class="lineNum">    2864 </span>            :     //!@{
<span class="lineNum">    2865 </span>            :     /*!
<span class="lineNum">    2866 </span>            :        return the sparse matrix iterator pointing to the first sparse matrix element
<span class="lineNum">    2867 </span>            :     */
<span class="lineNum">    2868 </span>            :     //! returns the sparse matrix iterator at the matrix beginning
<span class="lineNum">    2869 </span>            :     SparseMatIterator begin();
<span class="lineNum">    2870 </span>            :     //! returns the sparse matrix iterator at the matrix beginning
<span class="lineNum">    2871 </span>            :     template&lt;typename _Tp&gt; SparseMatIterator_&lt;_Tp&gt; begin();
<span class="lineNum">    2872 </span>            :     //! returns the read-only sparse matrix iterator at the matrix beginning
<span class="lineNum">    2873 </span>            :     SparseMatConstIterator begin() const;
<span class="lineNum">    2874 </span>            :     //! returns the read-only sparse matrix iterator at the matrix beginning
<span class="lineNum">    2875 </span>            :     template&lt;typename _Tp&gt; SparseMatConstIterator_&lt;_Tp&gt; begin() const;
<span class="lineNum">    2876 </span>            :     //!@}
<span class="lineNum">    2877 </span>            :     /*!
<span class="lineNum">    2878 </span>            :        return the sparse matrix iterator pointing to the element following the last sparse matrix element
<span class="lineNum">    2879 </span>            :     */
<span class="lineNum">    2880 </span>            :     //! returns the sparse matrix iterator at the matrix end
<span class="lineNum">    2881 </span>            :     SparseMatIterator end();
<span class="lineNum">    2882 </span>            :     //! returns the read-only sparse matrix iterator at the matrix end
<span class="lineNum">    2883 </span>            :     SparseMatConstIterator end() const;
<span class="lineNum">    2884 </span>            :     //! returns the typed sparse matrix iterator at the matrix end
<span class="lineNum">    2885 </span>            :     template&lt;typename _Tp&gt; SparseMatIterator_&lt;_Tp&gt; end();
<span class="lineNum">    2886 </span>            :     //! returns the typed read-only sparse matrix iterator at the matrix end
<span class="lineNum">    2887 </span>            :     template&lt;typename _Tp&gt; SparseMatConstIterator_&lt;_Tp&gt; end() const;
<span class="lineNum">    2888 </span>            : 
<span class="lineNum">    2889 </span>            :     //! returns the value stored in the sparse martix node
<span class="lineNum">    2890 </span>            :     template&lt;typename _Tp&gt; _Tp&amp; value(Node* n);
<span class="lineNum">    2891 </span>            :     //! returns the value stored in the sparse martix node
<span class="lineNum">    2892 </span>            :     template&lt;typename _Tp&gt; const _Tp&amp; value(const Node* n) const;
<span class="lineNum">    2893 </span>            : 
<span class="lineNum">    2894 </span>            :     ////////////// some internal-use methods ///////////////
<span class="lineNum">    2895 </span>            :     Node* node(size_t nidx);
<span class="lineNum">    2896 </span>            :     const Node* node(size_t nidx) const;
<span class="lineNum">    2897 </span>            : 
<span class="lineNum">    2898 </span>            :     uchar* newNode(const int* idx, size_t hashval);
<span class="lineNum">    2899 </span>            :     void removeNode(size_t hidx, size_t nidx, size_t previdx);
<span class="lineNum">    2900 </span>            :     void resizeHashTab(size_t newsize);
<span class="lineNum">    2901 </span>            : 
<span class="lineNum">    2902 </span>            :     int flags;
<span class="lineNum">    2903 </span>            :     Hdr* hdr;
<span class="lineNum">    2904 </span>            : };
<span class="lineNum">    2905 </span>            : 
<span class="lineNum">    2906 </span>            : 
<span class="lineNum">    2907 </span>            : 
<span class="lineNum">    2908 </span>            : ///////////////////////////////// SparseMat_&lt;_Tp&gt; ////////////////////////////////////
<span class="lineNum">    2909 </span>            : 
<span class="lineNum">    2910 </span>            : /** @brief Template sparse n-dimensional array class derived from SparseMat
<span class="lineNum">    2911 </span>            : 
<span class="lineNum">    2912 </span>            : SparseMat_ is a thin wrapper on top of SparseMat created in the same way as Mat_ . It simplifies
<span class="lineNum">    2913 </span>            : notation of some operations:
<span class="lineNum">    2914 </span>            : @code
<span class="lineNum">    2915 </span>            :     int sz[] = {10, 20, 30};
<span class="lineNum">    2916 </span>            :     SparseMat_&lt;double&gt; M(3, sz);
<span class="lineNum">    2917 </span>            :     ...
<span class="lineNum">    2918 </span>            :     M.ref(1, 2, 3) = M(4, 5, 6) + M(7, 8, 9);
<span class="lineNum">    2919 </span>            : @endcode
<span class="lineNum">    2920 </span>            :  */
<span class="lineNum">    2921 </span>            : template&lt;typename _Tp&gt; class SparseMat_ : public SparseMat
<span class="lineNum">    2922 </span>            : {
<span class="lineNum">    2923 </span>            : public:
<span class="lineNum">    2924 </span>            :     typedef SparseMatIterator_&lt;_Tp&gt; iterator;
<span class="lineNum">    2925 </span>            :     typedef SparseMatConstIterator_&lt;_Tp&gt; const_iterator;
<span class="lineNum">    2926 </span>            : 
<span class="lineNum">    2927 </span>            :     //! the default constructor
<span class="lineNum">    2928 </span>            :     SparseMat_();
<span class="lineNum">    2929 </span>            :     //! the full constructor equivelent to SparseMat(dims, _sizes, DataType&lt;_Tp&gt;::type)
<span class="lineNum">    2930 </span>            :     SparseMat_(int dims, const int* _sizes);
<span class="lineNum">    2931 </span>            :     //! the copy constructor. If DataType&lt;_Tp&gt;.type != m.type(), the m elements are converted
<span class="lineNum">    2932 </span>            :     SparseMat_(const SparseMat&amp; m);
<span class="lineNum">    2933 </span>            :     //! the copy constructor. This is O(1) operation - no data is copied
<span class="lineNum">    2934 </span>            :     SparseMat_(const SparseMat_&amp; m);
<span class="lineNum">    2935 </span>            :     //! converts dense matrix to the sparse form
<span class="lineNum">    2936 </span>            :     SparseMat_(const Mat&amp; m);
<span class="lineNum">    2937 </span>            :     //! converts the old-style sparse matrix to the C++ class. All the elements are copied
<span class="lineNum">    2938 </span>            :     //SparseMat_(const CvSparseMat* m);
<span class="lineNum">    2939 </span>            :     //! the assignment operator. If DataType&lt;_Tp&gt;.type != m.type(), the m elements are converted
<span class="lineNum">    2940 </span>            :     SparseMat_&amp; operator = (const SparseMat&amp; m);
<span class="lineNum">    2941 </span>            :     //! the assignment operator. This is O(1) operation - no data is copied
<span class="lineNum">    2942 </span>            :     SparseMat_&amp; operator = (const SparseMat_&amp; m);
<span class="lineNum">    2943 </span>            :     //! converts dense matrix to the sparse form
<span class="lineNum">    2944 </span>            :     SparseMat_&amp; operator = (const Mat&amp; m);
<span class="lineNum">    2945 </span>            : 
<span class="lineNum">    2946 </span>            :     //! makes full copy of the matrix. All the elements are duplicated
<span class="lineNum">    2947 </span>            :     SparseMat_ clone() const;
<span class="lineNum">    2948 </span>            :     //! equivalent to cv::SparseMat::create(dims, _sizes, DataType&lt;_Tp&gt;::type)
<span class="lineNum">    2949 </span>            :     void create(int dims, const int* _sizes);
<span class="lineNum">    2950 </span>            :     //! converts sparse matrix to the old-style CvSparseMat. All the elements are copied
<span class="lineNum">    2951 </span>            :     //operator CvSparseMat*() const;
<span class="lineNum">    2952 </span>            : 
<span class="lineNum">    2953 </span>            :     //! returns type of the matrix elements
<span class="lineNum">    2954 </span>            :     int type() const;
<span class="lineNum">    2955 </span>            :     //! returns depth of the matrix elements
<span class="lineNum">    2956 </span>            :     int depth() const;
<span class="lineNum">    2957 </span>            :     //! returns the number of channels in each matrix element
<span class="lineNum">    2958 </span>            :     int channels() const;
<span class="lineNum">    2959 </span>            : 
<span class="lineNum">    2960 </span>            :     //! equivalent to SparseMat::ref&lt;_Tp&gt;(i0, hashval)
<span class="lineNum">    2961 </span>            :     _Tp&amp; ref(int i0, size_t* hashval=0);
<span class="lineNum">    2962 </span>            :     //! equivalent to SparseMat::ref&lt;_Tp&gt;(i0, i1, hashval)
<span class="lineNum">    2963 </span>            :     _Tp&amp; ref(int i0, int i1, size_t* hashval=0);
<span class="lineNum">    2964 </span>            :     //! equivalent to SparseMat::ref&lt;_Tp&gt;(i0, i1, i2, hashval)
<span class="lineNum">    2965 </span>            :     _Tp&amp; ref(int i0, int i1, int i2, size_t* hashval=0);
<span class="lineNum">    2966 </span>            :     //! equivalent to SparseMat::ref&lt;_Tp&gt;(idx, hashval)
<span class="lineNum">    2967 </span>            :     _Tp&amp; ref(const int* idx, size_t* hashval=0);
<span class="lineNum">    2968 </span>            : 
<span class="lineNum">    2969 </span>            :     //! equivalent to SparseMat::value&lt;_Tp&gt;(i0, hashval)
<span class="lineNum">    2970 </span>            :     _Tp operator()(int i0, size_t* hashval=0) const;
<span class="lineNum">    2971 </span>            :     //! equivalent to SparseMat::value&lt;_Tp&gt;(i0, i1, hashval)
<span class="lineNum">    2972 </span>            :     _Tp operator()(int i0, int i1, size_t* hashval=0) const;
<span class="lineNum">    2973 </span>            :     //! equivalent to SparseMat::value&lt;_Tp&gt;(i0, i1, i2, hashval)
<span class="lineNum">    2974 </span>            :     _Tp operator()(int i0, int i1, int i2, size_t* hashval=0) const;
<span class="lineNum">    2975 </span>            :     //! equivalent to SparseMat::value&lt;_Tp&gt;(idx, hashval)
<span class="lineNum">    2976 </span>            :     _Tp operator()(const int* idx, size_t* hashval=0) const;
<span class="lineNum">    2977 </span>            : 
<span class="lineNum">    2978 </span>            :     //! returns sparse matrix iterator pointing to the first sparse matrix element
<span class="lineNum">    2979 </span>            :     SparseMatIterator_&lt;_Tp&gt; begin();
<span class="lineNum">    2980 </span>            :     //! returns read-only sparse matrix iterator pointing to the first sparse matrix element
<span class="lineNum">    2981 </span>            :     SparseMatConstIterator_&lt;_Tp&gt; begin() const;
<span class="lineNum">    2982 </span>            :     //! returns sparse matrix iterator pointing to the element following the last sparse matrix element
<span class="lineNum">    2983 </span>            :     SparseMatIterator_&lt;_Tp&gt; end();
<span class="lineNum">    2984 </span>            :     //! returns read-only sparse matrix iterator pointing to the element following the last sparse matrix element
<span class="lineNum">    2985 </span>            :     SparseMatConstIterator_&lt;_Tp&gt; end() const;
<span class="lineNum">    2986 </span>            : };
<span class="lineNum">    2987 </span>            : 
<span class="lineNum">    2988 </span>            : 
<span class="lineNum">    2989 </span>            : 
<span class="lineNum">    2990 </span>            : ////////////////////////////////// MatConstIterator //////////////////////////////////
<span class="lineNum">    2991 </span>            : 
<span class="lineNum">    2992 </span>            : class CV_EXPORTS MatConstIterator
<span class="lineNum">    2993 </span>            : {
<span class="lineNum">    2994 </span>            : public:
<span class="lineNum">    2995 </span>            :     typedef uchar* value_type;
<span class="lineNum">    2996 </span>            :     typedef ptrdiff_t difference_type;
<span class="lineNum">    2997 </span>            :     typedef const uchar** pointer;
<span class="lineNum">    2998 </span>            :     typedef uchar* reference;
<span class="lineNum">    2999 </span>            : 
<span class="lineNum">    3000 </span>            :     typedef std::random_access_iterator_tag iterator_category;
<span class="lineNum">    3001 </span>            : 
<span class="lineNum">    3002 </span>            :     //! default constructor
<span class="lineNum">    3003 </span>            :     MatConstIterator();
<span class="lineNum">    3004 </span>            :     //! constructor that sets the iterator to the beginning of the matrix
<span class="lineNum">    3005 </span>            :     MatConstIterator(const Mat* _m);
<span class="lineNum">    3006 </span>            :     //! constructor that sets the iterator to the specified element of the matrix
<span class="lineNum">    3007 </span>            :     MatConstIterator(const Mat* _m, int _row, int _col=0);
<span class="lineNum">    3008 </span>            :     //! constructor that sets the iterator to the specified element of the matrix
<span class="lineNum">    3009 </span>            :     MatConstIterator(const Mat* _m, Point _pt);
<span class="lineNum">    3010 </span>            :     //! constructor that sets the iterator to the specified element of the matrix
<span class="lineNum">    3011 </span>            :     MatConstIterator(const Mat* _m, const int* _idx);
<span class="lineNum">    3012 </span>            :     //! copy constructor
<span class="lineNum">    3013 </span>            :     MatConstIterator(const MatConstIterator&amp; it);
<span class="lineNum">    3014 </span>            : 
<span class="lineNum">    3015 </span>            :     //! copy operator
<span class="lineNum">    3016 </span>            :     MatConstIterator&amp; operator = (const MatConstIterator&amp; it);
<span class="lineNum">    3017 </span>            :     //! returns the current matrix element
<span class="lineNum">    3018 </span>            :     const uchar* operator *() const;
<span class="lineNum">    3019 </span>            :     //! returns the i-th matrix element, relative to the current
<span class="lineNum">    3020 </span>            :     const uchar* operator [](ptrdiff_t i) const;
<span class="lineNum">    3021 </span>            : 
<span class="lineNum">    3022 </span>            :     //! shifts the iterator forward by the specified number of elements
<span class="lineNum">    3023 </span>            :     MatConstIterator&amp; operator += (ptrdiff_t ofs);
<span class="lineNum">    3024 </span>            :     //! shifts the iterator backward by the specified number of elements
<span class="lineNum">    3025 </span>            :     MatConstIterator&amp; operator -= (ptrdiff_t ofs);
<span class="lineNum">    3026 </span>            :     //! decrements the iterator
<span class="lineNum">    3027 </span>            :     MatConstIterator&amp; operator --();
<span class="lineNum">    3028 </span>            :     //! decrements the iterator
<span class="lineNum">    3029 </span>            :     MatConstIterator operator --(int);
<span class="lineNum">    3030 </span>            :     //! increments the iterator
<span class="lineNum">    3031 </span>            :     MatConstIterator&amp; operator ++();
<span class="lineNum">    3032 </span>            :     //! increments the iterator
<span class="lineNum">    3033 </span>            :     MatConstIterator operator ++(int);
<span class="lineNum">    3034 </span>            :     //! returns the current iterator position
<span class="lineNum">    3035 </span>            :     Point pos() const;
<span class="lineNum">    3036 </span>            :     //! returns the current iterator position
<span class="lineNum">    3037 </span>            :     void pos(int* _idx) const;
<span class="lineNum">    3038 </span>            : 
<span class="lineNum">    3039 </span>            :     ptrdiff_t lpos() const;
<span class="lineNum">    3040 </span>            :     void seek(ptrdiff_t ofs, bool relative = false);
<span class="lineNum">    3041 </span>            :     void seek(const int* _idx, bool relative = false);
<span class="lineNum">    3042 </span>            : 
<span class="lineNum">    3043 </span>            :     const Mat* m;
<span class="lineNum">    3044 </span>            :     size_t elemSize;
<span class="lineNum">    3045 </span>            :     const uchar* ptr;
<span class="lineNum">    3046 </span>            :     const uchar* sliceStart;
<span class="lineNum">    3047 </span>            :     const uchar* sliceEnd;
<span class="lineNum">    3048 </span>            : };
<span class="lineNum">    3049 </span>            : 
<span class="lineNum">    3050 </span>            : 
<span class="lineNum">    3051 </span>            : 
<span class="lineNum">    3052 </span>            : ////////////////////////////////// MatConstIterator_ /////////////////////////////////
<span class="lineNum">    3053 </span>            : 
<span class="lineNum">    3054 </span>            : /** @brief Matrix read-only iterator
<span class="lineNum">    3055 </span>            :  */
<span class="lineNum">    3056 </span>            : template&lt;typename _Tp&gt;
<span class="lineNum">    3057 </span>            : class MatConstIterator_ : public MatConstIterator
<span class="lineNum">    3058 </span>            : {
<span class="lineNum">    3059 </span>            : public:
<span class="lineNum">    3060 </span>            :     typedef _Tp value_type;
<span class="lineNum">    3061 </span>            :     typedef ptrdiff_t difference_type;
<span class="lineNum">    3062 </span>            :     typedef const _Tp* pointer;
<span class="lineNum">    3063 </span>            :     typedef const _Tp&amp; reference;
<span class="lineNum">    3064 </span>            : 
<span class="lineNum">    3065 </span>            :     typedef std::random_access_iterator_tag iterator_category;
<span class="lineNum">    3066 </span>            : 
<span class="lineNum">    3067 </span>            :     //! default constructor
<span class="lineNum">    3068 </span>            :     MatConstIterator_();
<span class="lineNum">    3069 </span>            :     //! constructor that sets the iterator to the beginning of the matrix
<span class="lineNum">    3070 </span>            :     MatConstIterator_(const Mat_&lt;_Tp&gt;* _m);
<span class="lineNum">    3071 </span>            :     //! constructor that sets the iterator to the specified element of the matrix
<span class="lineNum">    3072 </span>            :     MatConstIterator_(const Mat_&lt;_Tp&gt;* _m, int _row, int _col=0);
<span class="lineNum">    3073 </span>            :     //! constructor that sets the iterator to the specified element of the matrix
<span class="lineNum">    3074 </span>            :     MatConstIterator_(const Mat_&lt;_Tp&gt;* _m, Point _pt);
<span class="lineNum">    3075 </span>            :     //! constructor that sets the iterator to the specified element of the matrix
<span class="lineNum">    3076 </span>            :     MatConstIterator_(const Mat_&lt;_Tp&gt;* _m, const int* _idx);
<span class="lineNum">    3077 </span>            :     //! copy constructor
<span class="lineNum">    3078 </span>            :     MatConstIterator_(const MatConstIterator_&amp; it);
<span class="lineNum">    3079 </span>            : 
<span class="lineNum">    3080 </span>            :     //! copy operator
<span class="lineNum">    3081 </span>            :     MatConstIterator_&amp; operator = (const MatConstIterator_&amp; it);
<span class="lineNum">    3082 </span>            :     //! returns the current matrix element
<span class="lineNum">    3083 </span>            :     const _Tp&amp; operator *() const;
<span class="lineNum">    3084 </span>            :     //! returns the i-th matrix element, relative to the current
<span class="lineNum">    3085 </span>            :     const _Tp&amp; operator [](ptrdiff_t i) const;
<span class="lineNum">    3086 </span>            : 
<span class="lineNum">    3087 </span>            :     //! shifts the iterator forward by the specified number of elements
<span class="lineNum">    3088 </span>            :     MatConstIterator_&amp; operator += (ptrdiff_t ofs);
<span class="lineNum">    3089 </span>            :     //! shifts the iterator backward by the specified number of elements
<span class="lineNum">    3090 </span>            :     MatConstIterator_&amp; operator -= (ptrdiff_t ofs);
<span class="lineNum">    3091 </span>            :     //! decrements the iterator
<span class="lineNum">    3092 </span>            :     MatConstIterator_&amp; operator --();
<span class="lineNum">    3093 </span>            :     //! decrements the iterator
<span class="lineNum">    3094 </span>            :     MatConstIterator_ operator --(int);
<span class="lineNum">    3095 </span>            :     //! increments the iterator
<span class="lineNum">    3096 </span>            :     MatConstIterator_&amp; operator ++();
<span class="lineNum">    3097 </span>            :     //! increments the iterator
<span class="lineNum">    3098 </span>            :     MatConstIterator_ operator ++(int);
<span class="lineNum">    3099 </span>            :     //! returns the current iterator position
<span class="lineNum">    3100 </span>            :     Point pos() const;
<span class="lineNum">    3101 </span>            : };
<span class="lineNum">    3102 </span>            : 
<span class="lineNum">    3103 </span>            : 
<span class="lineNum">    3104 </span>            : 
<span class="lineNum">    3105 </span>            : //////////////////////////////////// MatIterator_ ////////////////////////////////////
<span class="lineNum">    3106 </span>            : 
<span class="lineNum">    3107 </span>            : /** @brief Matrix read-write iterator
<span class="lineNum">    3108 </span>            : */
<span class="lineNum">    3109 </span>            : template&lt;typename _Tp&gt;
<span class="lineNum">    3110 </span>            : class MatIterator_ : public MatConstIterator_&lt;_Tp&gt;
<span class="lineNum">    3111 </span>            : {
<span class="lineNum">    3112 </span>            : public:
<span class="lineNum">    3113 </span>            :     typedef _Tp* pointer;
<span class="lineNum">    3114 </span>            :     typedef _Tp&amp; reference;
<span class="lineNum">    3115 </span>            : 
<span class="lineNum">    3116 </span>            :     typedef std::random_access_iterator_tag iterator_category;
<span class="lineNum">    3117 </span>            : 
<span class="lineNum">    3118 </span>            :     //! the default constructor
<span class="lineNum">    3119 </span>            :     MatIterator_();
<span class="lineNum">    3120 </span>            :     //! constructor that sets the iterator to the beginning of the matrix
<span class="lineNum">    3121 </span>            :     MatIterator_(Mat_&lt;_Tp&gt;* _m);
<span class="lineNum">    3122 </span>            :     //! constructor that sets the iterator to the specified element of the matrix
<span class="lineNum">    3123 </span>            :     MatIterator_(Mat_&lt;_Tp&gt;* _m, int _row, int _col=0);
<span class="lineNum">    3124 </span>            :     //! constructor that sets the iterator to the specified element of the matrix
<span class="lineNum">    3125 </span>            :     MatIterator_(Mat_&lt;_Tp&gt;* _m, Point _pt);
<span class="lineNum">    3126 </span>            :     //! constructor that sets the iterator to the specified element of the matrix
<span class="lineNum">    3127 </span>            :     MatIterator_(Mat_&lt;_Tp&gt;* _m, const int* _idx);
<span class="lineNum">    3128 </span>            :     //! copy constructor
<span class="lineNum">    3129 </span>            :     MatIterator_(const MatIterator_&amp; it);
<span class="lineNum">    3130 </span>            :     //! copy operator
<span class="lineNum">    3131 </span>            :     MatIterator_&amp; operator = (const MatIterator_&lt;_Tp&gt;&amp; it );
<span class="lineNum">    3132 </span>            : 
<span class="lineNum">    3133 </span>            :     //! returns the current matrix element
<span class="lineNum">    3134 </span>            :     _Tp&amp; operator *() const;
<span class="lineNum">    3135 </span>            :     //! returns the i-th matrix element, relative to the current
<span class="lineNum">    3136 </span>            :     _Tp&amp; operator [](ptrdiff_t i) const;
<span class="lineNum">    3137 </span>            : 
<span class="lineNum">    3138 </span>            :     //! shifts the iterator forward by the specified number of elements
<span class="lineNum">    3139 </span>            :     MatIterator_&amp; operator += (ptrdiff_t ofs);
<span class="lineNum">    3140 </span>            :     //! shifts the iterator backward by the specified number of elements
<span class="lineNum">    3141 </span>            :     MatIterator_&amp; operator -= (ptrdiff_t ofs);
<span class="lineNum">    3142 </span>            :     //! decrements the iterator
<span class="lineNum">    3143 </span>            :     MatIterator_&amp; operator --();
<span class="lineNum">    3144 </span>            :     //! decrements the iterator
<span class="lineNum">    3145 </span>            :     MatIterator_ operator --(int);
<span class="lineNum">    3146 </span>            :     //! increments the iterator
<span class="lineNum">    3147 </span>            :     MatIterator_&amp; operator ++();
<span class="lineNum">    3148 </span>            :     //! increments the iterator
<span class="lineNum">    3149 </span>            :     MatIterator_ operator ++(int);
<span class="lineNum">    3150 </span>            : };
<span class="lineNum">    3151 </span>            : 
<span class="lineNum">    3152 </span>            : 
<span class="lineNum">    3153 </span>            : 
<span class="lineNum">    3154 </span>            : /////////////////////////////// SparseMatConstIterator ///////////////////////////////
<span class="lineNum">    3155 </span>            : 
<span class="lineNum">    3156 </span>            : /**  @brief Read-Only Sparse Matrix Iterator.
<span class="lineNum">    3157 </span>            : 
<span class="lineNum">    3158 </span>            :  Here is how to use the iterator to compute the sum of floating-point sparse matrix elements:
<span class="lineNum">    3159 </span>            : 
<span class="lineNum">    3160 </span>            :  \code
<span class="lineNum">    3161 </span>            :  SparseMatConstIterator it = m.begin(), it_end = m.end();
<span class="lineNum">    3162 </span>            :  double s = 0;
<span class="lineNum">    3163 </span>            :  CV_Assert( m.type() == CV_32F );
<span class="lineNum">    3164 </span>            :  for( ; it != it_end; ++it )
<span class="lineNum">    3165 </span>            :     s += it.value&lt;float&gt;();
<span class="lineNum">    3166 </span>            :  \endcode
<span class="lineNum">    3167 </span>            : */
<span class="lineNum">    3168 </span>            : class CV_EXPORTS SparseMatConstIterator
<span class="lineNum">    3169 </span>            : {
<span class="lineNum">    3170 </span>            : public:
<span class="lineNum">    3171 </span>            :     //! the default constructor
<span class="lineNum">    3172 </span>            :     SparseMatConstIterator();
<span class="lineNum">    3173 </span>            :     //! the full constructor setting the iterator to the first sparse matrix element
<span class="lineNum">    3174 </span>            :     SparseMatConstIterator(const SparseMat* _m);
<span class="lineNum">    3175 </span>            :     //! the copy constructor
<span class="lineNum">    3176 </span>            :     SparseMatConstIterator(const SparseMatConstIterator&amp; it);
<span class="lineNum">    3177 </span>            : 
<span class="lineNum">    3178 </span>            :     //! the assignment operator
<span class="lineNum">    3179 </span>            :     SparseMatConstIterator&amp; operator = (const SparseMatConstIterator&amp; it);
<span class="lineNum">    3180 </span>            : 
<span class="lineNum">    3181 </span>            :     //! template method returning the current matrix element
<span class="lineNum">    3182 </span>            :     template&lt;typename _Tp&gt; const _Tp&amp; value() const;
<span class="lineNum">    3183 </span>            :     //! returns the current node of the sparse matrix. it.node-&gt;idx is the current element index
<span class="lineNum">    3184 </span>            :     const SparseMat::Node* node() const;
<span class="lineNum">    3185 </span>            : 
<span class="lineNum">    3186 </span>            :     //! moves iterator to the previous element
<span class="lineNum">    3187 </span>            :     SparseMatConstIterator&amp; operator --();
<span class="lineNum">    3188 </span>            :     //! moves iterator to the previous element
<span class="lineNum">    3189 </span>            :     SparseMatConstIterator operator --(int);
<span class="lineNum">    3190 </span>            :     //! moves iterator to the next element
<span class="lineNum">    3191 </span>            :     SparseMatConstIterator&amp; operator ++();
<span class="lineNum">    3192 </span>            :     //! moves iterator to the next element
<span class="lineNum">    3193 </span>            :     SparseMatConstIterator operator ++(int);
<span class="lineNum">    3194 </span>            : 
<span class="lineNum">    3195 </span>            :     //! moves iterator to the element after the last element
<span class="lineNum">    3196 </span>            :     void seekEnd();
<span class="lineNum">    3197 </span>            : 
<span class="lineNum">    3198 </span>            :     const SparseMat* m;
<span class="lineNum">    3199 </span>            :     size_t hashidx;
<span class="lineNum">    3200 </span>            :     uchar* ptr;
<span class="lineNum">    3201 </span>            : };
<span class="lineNum">    3202 </span>            : 
<span class="lineNum">    3203 </span>            : 
<span class="lineNum">    3204 </span>            : 
<span class="lineNum">    3205 </span>            : ////////////////////////////////// SparseMatIterator /////////////////////////////////
<span class="lineNum">    3206 </span>            : 
<span class="lineNum">    3207 </span>            : /** @brief  Read-write Sparse Matrix Iterator
<span class="lineNum">    3208 </span>            : 
<span class="lineNum">    3209 </span>            :  The class is similar to cv::SparseMatConstIterator,
<span class="lineNum">    3210 </span>            :  but can be used for in-place modification of the matrix elements.
<span class="lineNum">    3211 </span>            : */
<span class="lineNum">    3212 </span>            : class CV_EXPORTS SparseMatIterator : public SparseMatConstIterator
<span class="lineNum">    3213 </span>            : {
<span class="lineNum">    3214 </span>            : public:
<span class="lineNum">    3215 </span>            :     //! the default constructor
<span class="lineNum">    3216 </span>            :     SparseMatIterator();
<span class="lineNum">    3217 </span>            :     //! the full constructor setting the iterator to the first sparse matrix element
<span class="lineNum">    3218 </span>            :     SparseMatIterator(SparseMat* _m);
<span class="lineNum">    3219 </span>            :     //! the full constructor setting the iterator to the specified sparse matrix element
<span class="lineNum">    3220 </span>            :     SparseMatIterator(SparseMat* _m, const int* idx);
<span class="lineNum">    3221 </span>            :     //! the copy constructor
<span class="lineNum">    3222 </span>            :     SparseMatIterator(const SparseMatIterator&amp; it);
<span class="lineNum">    3223 </span>            : 
<span class="lineNum">    3224 </span>            :     //! the assignment operator
<span class="lineNum">    3225 </span>            :     SparseMatIterator&amp; operator = (const SparseMatIterator&amp; it);
<span class="lineNum">    3226 </span>            :     //! returns read-write reference to the current sparse matrix element
<span class="lineNum">    3227 </span>            :     template&lt;typename _Tp&gt; _Tp&amp; value() const;
<span class="lineNum">    3228 </span>            :     //! returns pointer to the current sparse matrix node. it.node-&gt;idx is the index of the current element (do not modify it!)
<span class="lineNum">    3229 </span>            :     SparseMat::Node* node() const;
<span class="lineNum">    3230 </span>            : 
<span class="lineNum">    3231 </span>            :     //! moves iterator to the next element
<span class="lineNum">    3232 </span>            :     SparseMatIterator&amp; operator ++();
<span class="lineNum">    3233 </span>            :     //! moves iterator to the next element
<span class="lineNum">    3234 </span>            :     SparseMatIterator operator ++(int);
<span class="lineNum">    3235 </span>            : };
<span class="lineNum">    3236 </span>            : 
<span class="lineNum">    3237 </span>            : 
<span class="lineNum">    3238 </span>            : 
<span class="lineNum">    3239 </span>            : /////////////////////////////// SparseMatConstIterator_ //////////////////////////////
<span class="lineNum">    3240 </span>            : 
<span class="lineNum">    3241 </span>            : /** @brief  Template Read-Only Sparse Matrix Iterator Class.
<span class="lineNum">    3242 </span>            : 
<span class="lineNum">    3243 </span>            :  This is the derived from SparseMatConstIterator class that
<span class="lineNum">    3244 </span>            :  introduces more convenient operator *() for accessing the current element.
<span class="lineNum">    3245 </span>            : */
<span class="lineNum">    3246 </span>            : template&lt;typename _Tp&gt; class SparseMatConstIterator_ : public SparseMatConstIterator
<span class="lineNum">    3247 </span>            : {
<span class="lineNum">    3248 </span>            : public:
<span class="lineNum">    3249 </span>            : 
<span class="lineNum">    3250 </span>            :     typedef std::forward_iterator_tag iterator_category;
<span class="lineNum">    3251 </span>            : 
<span class="lineNum">    3252 </span>            :     //! the default constructor
<span class="lineNum">    3253 </span>            :     SparseMatConstIterator_();
<span class="lineNum">    3254 </span>            :     //! the full constructor setting the iterator to the first sparse matrix element
<span class="lineNum">    3255 </span>            :     SparseMatConstIterator_(const SparseMat_&lt;_Tp&gt;* _m);
<span class="lineNum">    3256 </span>            :     SparseMatConstIterator_(const SparseMat* _m);
<span class="lineNum">    3257 </span>            :     //! the copy constructor
<span class="lineNum">    3258 </span>            :     SparseMatConstIterator_(const SparseMatConstIterator_&amp; it);
<span class="lineNum">    3259 </span>            : 
<span class="lineNum">    3260 </span>            :     //! the assignment operator
<span class="lineNum">    3261 </span>            :     SparseMatConstIterator_&amp; operator = (const SparseMatConstIterator_&amp; it);
<span class="lineNum">    3262 </span>            :     //! the element access operator
<span class="lineNum">    3263 </span>            :     const _Tp&amp; operator *() const;
<span class="lineNum">    3264 </span>            : 
<span class="lineNum">    3265 </span>            :     //! moves iterator to the next element
<span class="lineNum">    3266 </span>            :     SparseMatConstIterator_&amp; operator ++();
<span class="lineNum">    3267 </span>            :     //! moves iterator to the next element
<span class="lineNum">    3268 </span>            :     SparseMatConstIterator_ operator ++(int);
<span class="lineNum">    3269 </span>            : };
<span class="lineNum">    3270 </span>            : 
<span class="lineNum">    3271 </span>            : 
<span class="lineNum">    3272 </span>            : 
<span class="lineNum">    3273 </span>            : ///////////////////////////////// SparseMatIterator_ /////////////////////////////////
<span class="lineNum">    3274 </span>            : 
<span class="lineNum">    3275 </span>            : /** @brief  Template Read-Write Sparse Matrix Iterator Class.
<span class="lineNum">    3276 </span>            : 
<span class="lineNum">    3277 </span>            :  This is the derived from cv::SparseMatConstIterator_ class that
<span class="lineNum">    3278 </span>            :  introduces more convenient operator *() for accessing the current element.
<span class="lineNum">    3279 </span>            : */
<span class="lineNum">    3280 </span>            : template&lt;typename _Tp&gt; class SparseMatIterator_ : public SparseMatConstIterator_&lt;_Tp&gt;
<span class="lineNum">    3281 </span>            : {
<span class="lineNum">    3282 </span>            : public:
<span class="lineNum">    3283 </span>            : 
<span class="lineNum">    3284 </span>            :     typedef std::forward_iterator_tag iterator_category;
<span class="lineNum">    3285 </span>            : 
<span class="lineNum">    3286 </span>            :     //! the default constructor
<span class="lineNum">    3287 </span>            :     SparseMatIterator_();
<span class="lineNum">    3288 </span>            :     //! the full constructor setting the iterator to the first sparse matrix element
<span class="lineNum">    3289 </span>            :     SparseMatIterator_(SparseMat_&lt;_Tp&gt;* _m);
<span class="lineNum">    3290 </span>            :     SparseMatIterator_(SparseMat* _m);
<span class="lineNum">    3291 </span>            :     //! the copy constructor
<span class="lineNum">    3292 </span>            :     SparseMatIterator_(const SparseMatIterator_&amp; it);
<span class="lineNum">    3293 </span>            : 
<span class="lineNum">    3294 </span>            :     //! the assignment operator
<span class="lineNum">    3295 </span>            :     SparseMatIterator_&amp; operator = (const SparseMatIterator_&amp; it);
<span class="lineNum">    3296 </span>            :     //! returns the reference to the current element
<span class="lineNum">    3297 </span>            :     _Tp&amp; operator *() const;
<span class="lineNum">    3298 </span>            : 
<span class="lineNum">    3299 </span>            :     //! moves the iterator to the next element
<span class="lineNum">    3300 </span>            :     SparseMatIterator_&amp; operator ++();
<span class="lineNum">    3301 </span>            :     //! moves the iterator to the next element
<span class="lineNum">    3302 </span>            :     SparseMatIterator_ operator ++(int);
<span class="lineNum">    3303 </span>            : };
<span class="lineNum">    3304 </span>            : 
<span class="lineNum">    3305 </span>            : 
<span class="lineNum">    3306 </span>            : 
<span class="lineNum">    3307 </span>            : /////////////////////////////////// NAryMatIterator //////////////////////////////////
<span class="lineNum">    3308 </span>            : 
<span class="lineNum">    3309 </span>            : /** @brief n-ary multi-dimensional array iterator.
<span class="lineNum">    3310 </span>            : 
<span class="lineNum">    3311 </span>            : Use the class to implement unary, binary, and, generally, n-ary element-wise operations on
<span class="lineNum">    3312 </span>            : multi-dimensional arrays. Some of the arguments of an n-ary function may be continuous arrays, some
<span class="lineNum">    3313 </span>            : may be not. It is possible to use conventional MatIterator 's for each array but incrementing all of
<span class="lineNum">    3314 </span>            : the iterators after each small operations may be a big overhead. In this case consider using
<span class="lineNum">    3315 </span>            : NAryMatIterator to iterate through several matrices simultaneously as long as they have the same
<span class="lineNum">    3316 </span>            : geometry (dimensionality and all the dimension sizes are the same). On each iteration `it.planes[0]`,
<span class="lineNum">    3317 </span>            : `it.planes[1]`,... will be the slices of the corresponding matrices.
<span class="lineNum">    3318 </span>            : 
<span class="lineNum">    3319 </span>            : The example below illustrates how you can compute a normalized and threshold 3D color histogram:
<span class="lineNum">    3320 </span>            : @code
<span class="lineNum">    3321 </span>            :     void computeNormalizedColorHist(const Mat&amp; image, Mat&amp; hist, int N, double minProb)
<span class="lineNum">    3322 </span>            :     {
<span class="lineNum">    3323 </span>            :         const int histSize[] = {N, N, N};
<span class="lineNum">    3324 </span>            : 
<span class="lineNum">    3325 </span>            :         // make sure that the histogram has a proper size and type
<span class="lineNum">    3326 </span>            :         hist.create(3, histSize, CV_32F);
<span class="lineNum">    3327 </span>            : 
<span class="lineNum">    3328 </span>            :         // and clear it
<span class="lineNum">    3329 </span>            :         hist = Scalar(0);
<span class="lineNum">    3330 </span>            : 
<span class="lineNum">    3331 </span>            :         // the loop below assumes that the image
<span class="lineNum">    3332 </span>            :         // is a 8-bit 3-channel. check it.
<span class="lineNum">    3333 </span>            :         CV_Assert(image.type() == CV_8UC3);
<span class="lineNum">    3334 </span>            :         MatConstIterator_&lt;Vec3b&gt; it = image.begin&lt;Vec3b&gt;(),
<span class="lineNum">    3335 </span>            :                                  it_end = image.end&lt;Vec3b&gt;();
<span class="lineNum">    3336 </span>            :         for( ; it != it_end; ++it )
<span class="lineNum">    3337 </span>            :         {
<span class="lineNum">    3338 </span>            :             const Vec3b&amp; pix = *it;
<span class="lineNum">    3339 </span>            :             hist.at&lt;float&gt;(pix[0]*N/256, pix[1]*N/256, pix[2]*N/256) += 1.f;
<span class="lineNum">    3340 </span>            :         }
<span class="lineNum">    3341 </span>            : 
<span class="lineNum">    3342 </span>            :         minProb *= image.rows*image.cols;
<span class="lineNum">    3343 </span>            : 
<span class="lineNum">    3344 </span>            :         // initialize iterator (the style is different from STL).
<span class="lineNum">    3345 </span>            :         // after initialization the iterator will contain
<span class="lineNum">    3346 </span>            :         // the number of slices or planes the iterator will go through.
<span class="lineNum">    3347 </span>            :         // it simultaneously increments iterators for several matrices
<span class="lineNum">    3348 </span>            :         // supplied as a null terminated list of pointers
<span class="lineNum">    3349 </span>            :         const Mat* arrays[] = {&amp;hist, 0};
<span class="lineNum">    3350 </span>            :         Mat planes[1];
<span class="lineNum">    3351 </span>            :         NAryMatIterator itNAry(arrays, planes, 1);
<span class="lineNum">    3352 </span>            :         double s = 0;
<span class="lineNum">    3353 </span>            :         // iterate through the matrix. on each iteration
<span class="lineNum">    3354 </span>            :         // itNAry.planes[i] (of type Mat) will be set to the current plane
<span class="lineNum">    3355 </span>            :         // of the i-th n-dim matrix passed to the iterator constructor.
<span class="lineNum">    3356 </span>            :         for(int p = 0; p &lt; itNAry.nplanes; p++, ++itNAry)
<span class="lineNum">    3357 </span>            :         {
<span class="lineNum">    3358 </span>            :             threshold(itNAry.planes[0], itNAry.planes[0], minProb, 0, THRESH_TOZERO);
<span class="lineNum">    3359 </span>            :             s += sum(itNAry.planes[0])[0];
<span class="lineNum">    3360 </span>            :         }
<span class="lineNum">    3361 </span>            : 
<span class="lineNum">    3362 </span>            :         s = 1./s;
<span class="lineNum">    3363 </span>            :         itNAry = NAryMatIterator(arrays, planes, 1);
<span class="lineNum">    3364 </span>            :         for(int p = 0; p &lt; itNAry.nplanes; p++, ++itNAry)
<span class="lineNum">    3365 </span>            :             itNAry.planes[0] *= s;
<span class="lineNum">    3366 </span>            :     }
<span class="lineNum">    3367 </span>            : @endcode
<span class="lineNum">    3368 </span>            :  */
<span class="lineNum">    3369 </span>            : class CV_EXPORTS NAryMatIterator
<span class="lineNum">    3370 </span>            : {
<span class="lineNum">    3371 </span>            : public:
<span class="lineNum">    3372 </span>            :     //! the default constructor
<span class="lineNum">    3373 </span>            :     NAryMatIterator();
<span class="lineNum">    3374 </span>            :     //! the full constructor taking arbitrary number of n-dim matrices
<span class="lineNum">    3375 </span>            :     NAryMatIterator(const Mat** arrays, uchar** ptrs, int narrays=-1);
<span class="lineNum">    3376 </span>            :     //! the full constructor taking arbitrary number of n-dim matrices
<span class="lineNum">    3377 </span>            :     NAryMatIterator(const Mat** arrays, Mat* planes, int narrays=-1);
<span class="lineNum">    3378 </span>            :     //! the separate iterator initialization method
<span class="lineNum">    3379 </span>            :     void init(const Mat** arrays, Mat* planes, uchar** ptrs, int narrays=-1);
<span class="lineNum">    3380 </span>            : 
<span class="lineNum">    3381 </span>            :     //! proceeds to the next plane of every iterated matrix
<span class="lineNum">    3382 </span>            :     NAryMatIterator&amp; operator ++();
<span class="lineNum">    3383 </span>            :     //! proceeds to the next plane of every iterated matrix (postfix increment operator)
<span class="lineNum">    3384 </span>            :     NAryMatIterator operator ++(int);
<span class="lineNum">    3385 </span>            : 
<span class="lineNum">    3386 </span>            :     //! the iterated arrays
<span class="lineNum">    3387 </span>            :     const Mat** arrays;
<span class="lineNum">    3388 </span>            :     //! the current planes
<span class="lineNum">    3389 </span>            :     Mat* planes;
<span class="lineNum">    3390 </span>            :     //! data pointers
<span class="lineNum">    3391 </span>            :     uchar** ptrs;
<span class="lineNum">    3392 </span>            :     //! the number of arrays
<span class="lineNum">    3393 </span>            :     int narrays;
<span class="lineNum">    3394 </span>            :     //! the number of hyper-planes that the iterator steps through
<span class="lineNum">    3395 </span>            :     size_t nplanes;
<span class="lineNum">    3396 </span>            :     //! the size of each segment (in elements)
<span class="lineNum">    3397 </span>            :     size_t size;
<span class="lineNum">    3398 </span>            : protected:
<span class="lineNum">    3399 </span>            :     int iterdepth;
<span class="lineNum">    3400 </span>            :     size_t idx;
<span class="lineNum">    3401 </span>            : };
<span class="lineNum">    3402 </span>            : 
<span class="lineNum">    3403 </span>            : 
<span class="lineNum">    3404 </span>            : 
<span class="lineNum">    3405 </span>            : ///////////////////////////////// Matrix Expressions /////////////////////////////////
<span class="lineNum">    3406 </span>            : 
<span class="lineNum">    3407 </span>            : class CV_EXPORTS MatOp
<span class="lineNum">    3408 </span>            : {
<span class="lineNum">    3409 </span>            : public:
<span class="lineNum">    3410 </span>            :     MatOp();
<span class="lineNum">    3411 </span>            :     virtual ~MatOp();
<span class="lineNum">    3412 </span>            : 
<span class="lineNum">    3413 </span>            :     virtual bool elementWise(const MatExpr&amp; expr) const;
<span class="lineNum">    3414 </span>            :     virtual void assign(const MatExpr&amp; expr, Mat&amp; m, int type=-1) const = 0;
<span class="lineNum">    3415 </span>            :     virtual void roi(const MatExpr&amp; expr, const Range&amp; rowRange,
<span class="lineNum">    3416 </span>            :                      const Range&amp; colRange, MatExpr&amp; res) const;
<span class="lineNum">    3417 </span>            :     virtual void diag(const MatExpr&amp; expr, int d, MatExpr&amp; res) const;
<span class="lineNum">    3418 </span>            :     virtual void augAssignAdd(const MatExpr&amp; expr, Mat&amp; m) const;
<span class="lineNum">    3419 </span>            :     virtual void augAssignSubtract(const MatExpr&amp; expr, Mat&amp; m) const;
<span class="lineNum">    3420 </span>            :     virtual void augAssignMultiply(const MatExpr&amp; expr, Mat&amp; m) const;
<span class="lineNum">    3421 </span>            :     virtual void augAssignDivide(const MatExpr&amp; expr, Mat&amp; m) const;
<span class="lineNum">    3422 </span>            :     virtual void augAssignAnd(const MatExpr&amp; expr, Mat&amp; m) const;
<span class="lineNum">    3423 </span>            :     virtual void augAssignOr(const MatExpr&amp; expr, Mat&amp; m) const;
<span class="lineNum">    3424 </span>            :     virtual void augAssignXor(const MatExpr&amp; expr, Mat&amp; m) const;
<span class="lineNum">    3425 </span>            : 
<span class="lineNum">    3426 </span>            :     virtual void add(const MatExpr&amp; expr1, const MatExpr&amp; expr2, MatExpr&amp; res) const;
<span class="lineNum">    3427 </span>            :     virtual void add(const MatExpr&amp; expr1, const Scalar&amp; s, MatExpr&amp; res) const;
<span class="lineNum">    3428 </span>            : 
<span class="lineNum">    3429 </span>            :     virtual void subtract(const MatExpr&amp; expr1, const MatExpr&amp; expr2, MatExpr&amp; res) const;
<span class="lineNum">    3430 </span>            :     virtual void subtract(const Scalar&amp; s, const MatExpr&amp; expr, MatExpr&amp; res) const;
<span class="lineNum">    3431 </span>            : 
<span class="lineNum">    3432 </span>            :     virtual void multiply(const MatExpr&amp; expr1, const MatExpr&amp; expr2, MatExpr&amp; res, double scale=1) const;
<span class="lineNum">    3433 </span>            :     virtual void multiply(const MatExpr&amp; expr1, double s, MatExpr&amp; res) const;
<span class="lineNum">    3434 </span>            : 
<span class="lineNum">    3435 </span>            :     virtual void divide(const MatExpr&amp; expr1, const MatExpr&amp; expr2, MatExpr&amp; res, double scale=1) const;
<span class="lineNum">    3436 </span>            :     virtual void divide(double s, const MatExpr&amp; expr, MatExpr&amp; res) const;
<span class="lineNum">    3437 </span>            : 
<span class="lineNum">    3438 </span>            :     virtual void abs(const MatExpr&amp; expr, MatExpr&amp; res) const;
<span class="lineNum">    3439 </span>            : 
<span class="lineNum">    3440 </span>            :     virtual void transpose(const MatExpr&amp; expr, MatExpr&amp; res) const;
<span class="lineNum">    3441 </span>            :     virtual void matmul(const MatExpr&amp; expr1, const MatExpr&amp; expr2, MatExpr&amp; res) const;
<span class="lineNum">    3442 </span>            :     virtual void invert(const MatExpr&amp; expr, int method, MatExpr&amp; res) const;
<span class="lineNum">    3443 </span>            : 
<span class="lineNum">    3444 </span>            :     virtual Size size(const MatExpr&amp; expr) const;
<span class="lineNum">    3445 </span>            :     virtual int type(const MatExpr&amp; expr) const;
<span class="lineNum">    3446 </span>            : };
<span class="lineNum">    3447 </span>            : 
<span class="lineNum">    3448 </span>            : /** @brief Matrix expression representation
<span class="lineNum">    3449 </span>            : @anchor MatrixExpressions
<span class="lineNum">    3450 </span>            : This is a list of implemented matrix operations that can be combined in arbitrary complex
<span class="lineNum">    3451 </span>            : expressions (here A, B stand for matrices ( Mat ), s for a scalar ( Scalar ), alpha for a
<span class="lineNum">    3452 </span>            : real-valued scalar ( double )):
<span class="lineNum">    3453 </span>            : -   Addition, subtraction, negation: `A+B`, `A-B`, `A+s`, `A-s`, `s+A`, `s-A`, `-A`
<span class="lineNum">    3454 </span>            : -   Scaling: `A*alpha`
<span class="lineNum">    3455 </span>            : -   Per-element multiplication and division: `A.mul(B)`, `A/B`, `alpha/A`
<span class="lineNum">    3456 </span>            : -   Matrix multiplication: `A*B`
<span class="lineNum">    3457 </span>            : -   Transposition: `A.t()` (means A&lt;sup&gt;T&lt;/sup&gt;)
<span class="lineNum">    3458 </span>            : -   Matrix inversion and pseudo-inversion, solving linear systems and least-squares problems:
<span class="lineNum">    3459 </span>            :     `A.inv([method]) (~ A&lt;sup&gt;-1&lt;/sup&gt;)`,   `A.inv([method])*B (~ X: AX=B)`
<span class="lineNum">    3460 </span>            : -   Comparison: `A cmpop B`, `A cmpop alpha`, `alpha cmpop A`, where *cmpop* is one of
<span class="lineNum">    3461 </span>            :   `&gt;`, `&gt;=`, `==`, `!=`, `&lt;=`, `&lt;`. The result of comparison is an 8-bit single channel mask whose
<span class="lineNum">    3462 </span>            :     elements are set to 255 (if the particular element or pair of elements satisfy the condition) or
<span class="lineNum">    3463 </span>            :     0.
<span class="lineNum">    3464 </span>            : -   Bitwise logical operations: `A logicop B`, `A logicop s`, `s logicop A`, `~A`, where *logicop* is one of
<span class="lineNum">    3465 </span>            :   `&amp;`, `|`, `^`.
<span class="lineNum">    3466 </span>            : -   Element-wise minimum and maximum: `min(A, B)`, `min(A, alpha)`, `max(A, B)`, `max(A, alpha)`
<span class="lineNum">    3467 </span>            : -   Element-wise absolute value: `abs(A)`
<span class="lineNum">    3468 </span>            : -   Cross-product, dot-product: `A.cross(B)`, `A.dot(B)`
<span class="lineNum">    3469 </span>            : -   Any function of matrix or matrices and scalars that returns a matrix or a scalar, such as norm,
<span class="lineNum">    3470 </span>            :     mean, sum, countNonZero, trace, determinant, repeat, and others.
<span class="lineNum">    3471 </span>            : -   Matrix initializers ( Mat::eye(), Mat::zeros(), Mat::ones() ), matrix comma-separated
<span class="lineNum">    3472 </span>            :     initializers, matrix constructors and operators that extract sub-matrices (see Mat description).
<span class="lineNum">    3473 </span>            : -   Mat_&lt;destination_type&gt;() constructors to cast the result to the proper type.
<span class="lineNum">    3474 </span>            : @note Comma-separated initializers and probably some other operations may require additional
<span class="lineNum">    3475 </span>            : explicit Mat() or Mat_&lt;T&gt;() constructor calls to resolve a possible ambiguity.
<span class="lineNum">    3476 </span>            : 
<span class="lineNum">    3477 </span>            : Here are examples of matrix expressions:
<span class="lineNum">    3478 </span>            : @code
<span class="lineNum">    3479 </span>            :     // compute pseudo-inverse of A, equivalent to A.inv(DECOMP_SVD)
<span class="lineNum">    3480 </span>            :     SVD svd(A);
<span class="lineNum">    3481 </span>            :     Mat pinvA = svd.vt.t()*Mat::diag(1./svd.w)*svd.u.t();
<span class="lineNum">    3482 </span>            : 
<span class="lineNum">    3483 </span>            :     // compute the new vector of parameters in the Levenberg-Marquardt algorithm
<span class="lineNum">    3484 </span>            :     x -= (A.t()*A + lambda*Mat::eye(A.cols,A.cols,A.type())).inv(DECOMP_CHOLESKY)*(A.t()*err);
<span class="lineNum">    3485 </span>            : 
<span class="lineNum">    3486 </span>            :     // sharpen image using &quot;unsharp mask&quot; algorithm
<span class="lineNum">    3487 </span>            :     Mat blurred; double sigma = 1, threshold = 5, amount = 1;
<span class="lineNum">    3488 </span>            :     GaussianBlur(img, blurred, Size(), sigma, sigma);
<span class="lineNum">    3489 </span>            :     Mat lowContrastMask = abs(img - blurred) &lt; threshold;
<span class="lineNum">    3490 </span>            :     Mat sharpened = img*(1+amount) + blurred*(-amount);
<span class="lineNum">    3491 </span>            :     img.copyTo(sharpened, lowContrastMask);
<span class="lineNum">    3492 </span>            : @endcode
<span class="lineNum">    3493 </span>            : */
<span class="lineNum">    3494 </span>            : class CV_EXPORTS MatExpr
<span class="lineNum">    3495 </span>            : {
<span class="lineNum">    3496 </span>            : public:
<span class="lineNum">    3497 </span>            :     MatExpr();
<span class="lineNum">    3498 </span>            :     explicit MatExpr(const Mat&amp; m);
<span class="lineNum">    3499 </span>            : 
<span class="lineNum">    3500 </span>            :     MatExpr(const MatOp* _op, int _flags, const Mat&amp; _a = Mat(), const Mat&amp; _b = Mat(),
<span class="lineNum">    3501 </span>            :             const Mat&amp; _c = Mat(), double _alpha = 1, double _beta = 1, const Scalar&amp; _s = Scalar());
<span class="lineNum">    3502 </span>            : 
<span class="lineNum">    3503 </span>            :     operator Mat() const;
<span class="lineNum">    3504 </span>            :     template&lt;typename _Tp&gt; operator Mat_&lt;_Tp&gt;() const;
<span class="lineNum">    3505 </span>            : 
<span class="lineNum">    3506 </span>            :     Size size() const;
<span class="lineNum">    3507 </span>            :     int type() const;
<span class="lineNum">    3508 </span>            : 
<span class="lineNum">    3509 </span>            :     MatExpr row(int y) const;
<span class="lineNum">    3510 </span>            :     MatExpr col(int x) const;
<span class="lineNum">    3511 </span>            :     MatExpr diag(int d = 0) const;
<span class="lineNum">    3512 </span>            :     MatExpr operator()( const Range&amp; rowRange, const Range&amp; colRange ) const;
<span class="lineNum">    3513 </span>            :     MatExpr operator()( const Rect&amp; roi ) const;
<span class="lineNum">    3514 </span>            : 
<span class="lineNum">    3515 </span>            :     MatExpr t() const;
<span class="lineNum">    3516 </span>            :     MatExpr inv(int method = DECOMP_LU) const;
<span class="lineNum">    3517 </span>            :     MatExpr mul(const MatExpr&amp; e, double scale=1) const;
<span class="lineNum">    3518 </span>            :     MatExpr mul(const Mat&amp; m, double scale=1) const;
<span class="lineNum">    3519 </span>            : 
<span class="lineNum">    3520 </span>            :     Mat cross(const Mat&amp; m) const;
<span class="lineNum">    3521 </span>            :     double dot(const Mat&amp; m) const;
<span class="lineNum">    3522 </span>            : 
<span class="lineNum">    3523 </span>            :     const MatOp* op;
<span class="lineNum">    3524 </span>            :     int flags;
<span class="lineNum">    3525 </span>            : 
<span class="lineNum">    3526 </span>            :     Mat a, b, c;
<span class="lineNum">    3527 </span>            :     double alpha, beta;
<span class="lineNum">    3528 </span>            :     Scalar s;
<span class="lineNum">    3529 </span>            : };
<span class="lineNum">    3530 </span>            : 
<span class="lineNum">    3531 </span>            : //! @} core_basic
<span class="lineNum">    3532 </span>            : 
<span class="lineNum">    3533 </span>            : //! @relates cv::MatExpr
<span class="lineNum">    3534 </span>            : //! @{
<span class="lineNum">    3535 </span>            : CV_EXPORTS MatExpr operator + (const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3536 </span>            : CV_EXPORTS MatExpr operator + (const Mat&amp; a, const Scalar&amp; s);
<span class="lineNum">    3537 </span>            : CV_EXPORTS MatExpr operator + (const Scalar&amp; s, const Mat&amp; a);
<span class="lineNum">    3538 </span>            : CV_EXPORTS MatExpr operator + (const MatExpr&amp; e, const Mat&amp; m);
<span class="lineNum">    3539 </span>            : CV_EXPORTS MatExpr operator + (const Mat&amp; m, const MatExpr&amp; e);
<span class="lineNum">    3540 </span>            : CV_EXPORTS MatExpr operator + (const MatExpr&amp; e, const Scalar&amp; s);
<span class="lineNum">    3541 </span>            : CV_EXPORTS MatExpr operator + (const Scalar&amp; s, const MatExpr&amp; e);
<span class="lineNum">    3542 </span>            : CV_EXPORTS MatExpr operator + (const MatExpr&amp; e1, const MatExpr&amp; e2);
<span class="lineNum">    3543 </span>            : 
<span class="lineNum">    3544 </span>            : CV_EXPORTS MatExpr operator - (const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3545 </span>            : CV_EXPORTS MatExpr operator - (const Mat&amp; a, const Scalar&amp; s);
<span class="lineNum">    3546 </span>            : CV_EXPORTS MatExpr operator - (const Scalar&amp; s, const Mat&amp; a);
<span class="lineNum">    3547 </span>            : CV_EXPORTS MatExpr operator - (const MatExpr&amp; e, const Mat&amp; m);
<span class="lineNum">    3548 </span>            : CV_EXPORTS MatExpr operator - (const Mat&amp; m, const MatExpr&amp; e);
<span class="lineNum">    3549 </span>            : CV_EXPORTS MatExpr operator - (const MatExpr&amp; e, const Scalar&amp; s);
<span class="lineNum">    3550 </span>            : CV_EXPORTS MatExpr operator - (const Scalar&amp; s, const MatExpr&amp; e);
<span class="lineNum">    3551 </span>            : CV_EXPORTS MatExpr operator - (const MatExpr&amp; e1, const MatExpr&amp; e2);
<span class="lineNum">    3552 </span>            : 
<span class="lineNum">    3553 </span>            : CV_EXPORTS MatExpr operator - (const Mat&amp; m);
<span class="lineNum">    3554 </span>            : CV_EXPORTS MatExpr operator - (const MatExpr&amp; e);
<span class="lineNum">    3555 </span>            : 
<span class="lineNum">    3556 </span>            : CV_EXPORTS MatExpr operator * (const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3557 </span>            : CV_EXPORTS MatExpr operator * (const Mat&amp; a, double s);
<span class="lineNum">    3558 </span>            : CV_EXPORTS MatExpr operator * (double s, const Mat&amp; a);
<span class="lineNum">    3559 </span>            : CV_EXPORTS MatExpr operator * (const MatExpr&amp; e, const Mat&amp; m);
<span class="lineNum">    3560 </span>            : CV_EXPORTS MatExpr operator * (const Mat&amp; m, const MatExpr&amp; e);
<span class="lineNum">    3561 </span>            : CV_EXPORTS MatExpr operator * (const MatExpr&amp; e, double s);
<span class="lineNum">    3562 </span>            : CV_EXPORTS MatExpr operator * (double s, const MatExpr&amp; e);
<span class="lineNum">    3563 </span>            : CV_EXPORTS MatExpr operator * (const MatExpr&amp; e1, const MatExpr&amp; e2);
<span class="lineNum">    3564 </span>            : 
<span class="lineNum">    3565 </span>            : CV_EXPORTS MatExpr operator / (const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3566 </span>            : CV_EXPORTS MatExpr operator / (const Mat&amp; a, double s);
<span class="lineNum">    3567 </span>            : CV_EXPORTS MatExpr operator / (double s, const Mat&amp; a);
<span class="lineNum">    3568 </span>            : CV_EXPORTS MatExpr operator / (const MatExpr&amp; e, const Mat&amp; m);
<span class="lineNum">    3569 </span>            : CV_EXPORTS MatExpr operator / (const Mat&amp; m, const MatExpr&amp; e);
<span class="lineNum">    3570 </span>            : CV_EXPORTS MatExpr operator / (const MatExpr&amp; e, double s);
<span class="lineNum">    3571 </span>            : CV_EXPORTS MatExpr operator / (double s, const MatExpr&amp; e);
<span class="lineNum">    3572 </span>            : CV_EXPORTS MatExpr operator / (const MatExpr&amp; e1, const MatExpr&amp; e2);
<span class="lineNum">    3573 </span>            : 
<span class="lineNum">    3574 </span>            : CV_EXPORTS MatExpr operator &lt; (const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3575 </span>            : CV_EXPORTS MatExpr operator &lt; (const Mat&amp; a, double s);
<span class="lineNum">    3576 </span>            : CV_EXPORTS MatExpr operator &lt; (double s, const Mat&amp; a);
<span class="lineNum">    3577 </span>            : 
<span class="lineNum">    3578 </span>            : CV_EXPORTS MatExpr operator &lt;= (const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3579 </span>            : CV_EXPORTS MatExpr operator &lt;= (const Mat&amp; a, double s);
<span class="lineNum">    3580 </span>            : CV_EXPORTS MatExpr operator &lt;= (double s, const Mat&amp; a);
<span class="lineNum">    3581 </span>            : 
<span class="lineNum">    3582 </span>            : CV_EXPORTS MatExpr operator == (const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3583 </span>            : CV_EXPORTS MatExpr operator == (const Mat&amp; a, double s);
<span class="lineNum">    3584 </span>            : CV_EXPORTS MatExpr operator == (double s, const Mat&amp; a);
<span class="lineNum">    3585 </span>            : 
<span class="lineNum">    3586 </span>            : CV_EXPORTS MatExpr operator != (const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3587 </span>            : CV_EXPORTS MatExpr operator != (const Mat&amp; a, double s);
<span class="lineNum">    3588 </span>            : CV_EXPORTS MatExpr operator != (double s, const Mat&amp; a);
<span class="lineNum">    3589 </span>            : 
<span class="lineNum">    3590 </span>            : CV_EXPORTS MatExpr operator &gt;= (const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3591 </span>            : CV_EXPORTS MatExpr operator &gt;= (const Mat&amp; a, double s);
<span class="lineNum">    3592 </span>            : CV_EXPORTS MatExpr operator &gt;= (double s, const Mat&amp; a);
<span class="lineNum">    3593 </span>            : 
<span class="lineNum">    3594 </span>            : CV_EXPORTS MatExpr operator &gt; (const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3595 </span>            : CV_EXPORTS MatExpr operator &gt; (const Mat&amp; a, double s);
<span class="lineNum">    3596 </span>            : CV_EXPORTS MatExpr operator &gt; (double s, const Mat&amp; a);
<span class="lineNum">    3597 </span>            : 
<span class="lineNum">    3598 </span>            : CV_EXPORTS MatExpr operator &amp; (const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3599 </span>            : CV_EXPORTS MatExpr operator &amp; (const Mat&amp; a, const Scalar&amp; s);
<span class="lineNum">    3600 </span>            : CV_EXPORTS MatExpr operator &amp; (const Scalar&amp; s, const Mat&amp; a);
<span class="lineNum">    3601 </span>            : 
<span class="lineNum">    3602 </span>            : CV_EXPORTS MatExpr operator | (const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3603 </span>            : CV_EXPORTS MatExpr operator | (const Mat&amp; a, const Scalar&amp; s);
<span class="lineNum">    3604 </span>            : CV_EXPORTS MatExpr operator | (const Scalar&amp; s, const Mat&amp; a);
<span class="lineNum">    3605 </span>            : 
<span class="lineNum">    3606 </span>            : CV_EXPORTS MatExpr operator ^ (const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3607 </span>            : CV_EXPORTS MatExpr operator ^ (const Mat&amp; a, const Scalar&amp; s);
<span class="lineNum">    3608 </span>            : CV_EXPORTS MatExpr operator ^ (const Scalar&amp; s, const Mat&amp; a);
<span class="lineNum">    3609 </span>            : 
<span class="lineNum">    3610 </span>            : CV_EXPORTS MatExpr operator ~(const Mat&amp; m);
<span class="lineNum">    3611 </span>            : 
<span class="lineNum">    3612 </span>            : CV_EXPORTS MatExpr min(const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3613 </span>            : CV_EXPORTS MatExpr min(const Mat&amp; a, double s);
<span class="lineNum">    3614 </span>            : CV_EXPORTS MatExpr min(double s, const Mat&amp; a);
<span class="lineNum">    3615 </span>            : 
<span class="lineNum">    3616 </span>            : CV_EXPORTS MatExpr max(const Mat&amp; a, const Mat&amp; b);
<span class="lineNum">    3617 </span>            : CV_EXPORTS MatExpr max(const Mat&amp; a, double s);
<span class="lineNum">    3618 </span>            : CV_EXPORTS MatExpr max(double s, const Mat&amp; a);
<span class="lineNum">    3619 </span>            : 
<span class="lineNum">    3620 </span>            : /** @brief Calculates an absolute value of each matrix element.
<span class="lineNum">    3621 </span>            : 
<span class="lineNum">    3622 </span>            : abs is a meta-function that is expanded to one of absdiff or convertScaleAbs forms:
<span class="lineNum">    3623 </span>            : - C = abs(A-B) is equivalent to `absdiff(A, B, C)`
<span class="lineNum">    3624 </span>            : - C = abs(A) is equivalent to `absdiff(A, Scalar::all(0), C)`
<span class="lineNum">    3625 </span>            : - C = `Mat_&lt;Vec&lt;uchar,n&gt; &gt;(abs(A*alpha + beta))` is equivalent to `convertScaleAbs(A, C, alpha,
<span class="lineNum">    3626 </span>            : beta)`
<span class="lineNum">    3627 </span>            : 
<span class="lineNum">    3628 </span>            : The output matrix has the same size and the same type as the input one except for the last case,
<span class="lineNum">    3629 </span>            : where C is depth=CV_8U .
<span class="lineNum">    3630 </span>            : @param m matrix.
<span class="lineNum">    3631 </span>            : @sa @ref MatrixExpressions, absdiff, convertScaleAbs
<span class="lineNum">    3632 </span>            :  */
<span class="lineNum">    3633 </span>            : CV_EXPORTS MatExpr abs(const Mat&amp; m);
<span class="lineNum">    3634 </span>            : /** @overload
<span class="lineNum">    3635 </span>            : @param e matrix expression.
<span class="lineNum">    3636 </span>            : */
<span class="lineNum">    3637 </span>            : CV_EXPORTS MatExpr abs(const MatExpr&amp; e);
<span class="lineNum">    3638 </span>            : //! @} relates cv::MatExpr
<span class="lineNum">    3639 </span>            : 
<span class="lineNum">    3640 </span>            : } // cv
<span class="lineNum">    3641 </span>            : 
<span class="lineNum">    3642 </span>            : #include &quot;opencv2/core/mat.inl.hpp&quot;
<span class="lineNum">    3643 </span>            : 
<span class="lineNum">    3644 </span>            : #endif // OPENCV_CORE_MAT_HPP
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
